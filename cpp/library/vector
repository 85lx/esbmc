/*******************************************************************\
 *
 *
 * Author: Blanc Nicolas
 *
 * 
\*******************************************************************/


#ifndef STL_VECTOR
#define STL_VECTOR
#include <iostream>
#include <cassert>

namespace std
{

	#define VECTOR_CAPACITY 20

	template<class T> class vector
	{
		typedef T& reference;
		typedef const T& const_reference;
		typedef T& iterator;
		typedef const T& const_iterator;
		typedef T size_type;

	public:
		vector(): _size(0), _capacity(0){}
		vector(T t1, T t2): _size(0)
		{
			push_back(t1);
			push_back(t2);
		}
		vector(T t): _size(0)
		{
			push_back(t);
		}

		void push_back(const T& t)
		{
			assert(0 <= _size && _size < VECTOR_CAPACITY);
			buf[_size++] = t;
		}

		T& operator[] (int i)
		{
			assert(0 <= i && i < _size && _size <= VECTOR_CAPACITY);
			return buf[i];
		}
	
		const T& operator[] (int i) const
		{
			assert(0 <= i && i < _size && _size <= VECTOR_CAPACITY);
			return buf[i];
		}

		int size() const
		{
			assert(0 <= _size && _size <= VECTOR_CAPACITY);
			return _size;
		}
	
		int capacity() const
		{
			assert(0 <= _size && _size <= VECTOR_CAPACITY);
			return VECTOR_CAPACITY;
		}

		void resize ( T sz, T c = T() )
		{
			//model
		}

	    void pop_back()
	    {
	      __ESBMC_HIDE:
	      __ESBMC_assert(_size!=0, "pop_back() on empty vector");
	      resize(_size-1);

	    }

		bool operator==(const vector& v2): _size(0)
	    {/*
	      __ESBMC_HIDE:
	      if(v1._size != v2._size)return false;

	      for(unsigned i = 0; i < v1._size; i++)
	        if (v1._buf[i] != v2._buf[i]) return false;

	      return true;
	    */}

	    bool operator !=(const vector& v2): _size(0)
	    {/*
	      __ESBMC_HIDE:
	      return !(v1==v2);
	    */}

		T& max_size () const{
	    	// model
	    }
		reference back ( ){
	    	// model
	    }
	    const_reference back ( ) const{
	    	// model
	    }
	    const_reference at ( T n ) const{
	    	// model
	    }
	    reference at ( T n ){
	    	// model
	    }
	    iterator begin (){
	    	// model
	    }
	    const_iterator begin () const{
	    	// model
	    }
	    iterator end (){
	    	// model
	    }
	    const_iterator end () const{
	    	// model
	    }
	    bool empty () const{
	    	// model
	    }
	    void reserve ( T n ){
	    	// model
	    }
	    reference front ( ){
	    	// model
	    }
	    const_reference front ( ) const{
	    	// model
	    }
	    void assign ( size_type n, const T& u ){
	    	// model
	    }
	    T erase ( T position ){
	    	// model
	    }
	    T erase ( T first, T last ){
	    	// model
	    }
	    void clear ( ){
	    	// model
	    }
			    iterator insert ( iterator position, const T& x ){
	    	// model
	    }
	    void insert ( iterator position, size_type n, const T& x ){
	    	// model
	    }

	private:
		T buf[VECTOR_CAPACITY];
		int _size;
		int _capacity;

	};

#if 0
    class reverse_iterator
    {
#ifdef __STL_VERSIONS
  #ifndef VERSION
    #define VERSION(c,offset)   (c)->_version[(offset)]
  #endif
#else
  #ifndef VERSION
    #define VERSION(c,offset)   (c)->_version
  #endif
#endif

      public:
      reverse_iterator(vector *_v, unsigned _offset):
      v(_v),
      offset(_offset),
      version(VERSION(v, offset))
      {
      }

      reverse_iterator():
      v(0)
      {
      }
      protected:
      vector *v;
      unsigned offset;
      unsigned version;

    };
#endif

}

#endif
