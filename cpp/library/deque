/*******************************************************************\

Module: 

Author: Felipe Rodrigues and Lucas Cordeiro

Date: February 2012

\*******************************************************************/


#ifndef __STL_DEQUE
#define __STL_DEQUE

#include <vector>

namespace std {
  template <class T>
  class deque {
    public:

    // types:
    typedef T& reference;
    typedef const T& const_reference;


    class iterator{
      public:
	  vector<T>::iterator it;

	  iterator(vector<T>::iterator in){
		  it = in;
	  }

      iterator(const iterator& i){
    	  it = i.it;
      }
      iterator() : it(){

      }
      iterator& operator=(const iterator& i){
    	  it = i.it;
      }

      T* operator -> ();

      T& operator * (){
    	  return *it;
      }

      iterator& operator ++ (int b){
    	  it++;
    	  vector<T>::iterator it1 = it - 1;
    	  return iterator(it1);
      }

      iterator& operator ++ (){
          	  return iterator(++it);
            }

      iterator& operator -- (){
    	  return iterator(++it);
      }
      iterator& operator -- (int){
    	  return iterator(it++);
      }

      bool operator == ( const iterator& i)const{
    	  return (it == i.it);
      }
      bool operator != ( const iterator& i)const{
    	  return (it != i.it);
      }

      bool operator < ( const iterator& i)const{
    	  return (it < i.it);
      }
      bool operator > ( const iterator& i)const{
    	  return (it > i.it);
      }

      bool operator <= ( const iterator& i)const{
    	  return (it <= i.it);
      }
      bool operator >= ( const iterator& i)const{
    	  return (it >= i.it);
      }

      iterator operator + (int n) const{
    	  return iterator(it+n);
      }
      iterator operator - (int n) const{
    	  return iterator(it-n);
      }

      iterator& operator += (int n){
    	  return iterator(it+=n);
      }
      iterator& operator -= (int n){
    	  return iterator(it-=n);
      }
    };

    class const_iterator
    {
      public:
      const_iterator(const const_iterator&);
      const_iterator();
      const_iterator& operator=(const const_iterator&);

      const T* operator -> ();

      const T& operator * ();

      const_iterator& operator ++ ();
      const_iterator& operator ++ (int);

      const_iterator& operator -- ();
      const_iterator& operator -- (int);

      bool operator == ( const const_iterator&)const;
      bool operator != ( const const_iterator&)const;

      bool operator < ( const const_iterator&)const;
      bool operator > ( const const_iterator&)const;

      bool operator <= ( const const_iterator&)const;
      bool operator >= ( const const_iterator&)const;

      const_iterator operator + (int) const;
      const_iterator operator - (int) const;

      const_iterator& operator += (int);
      const_iterator& operator -= (int);
    };

    class reverse_iterator{
      public:
      reverse_iterator(const reverse_iterator&);
      reverse_iterator();
      reverse_iterator& operator=(const reverse_iterator&);

      T* operator -> ();

      T& operator * ();

      reverse_iterator& operator ++ ();
      reverse_iterator& operator ++ (int);

      reverse_iterator& operator -- ();
      reverse_iterator& operator -- (int);

      bool operator == ( const reverse_iterator&)const;
      bool operator != ( const reverse_iterator&)const;

      bool operator < ( const reverse_iterator&)const;
      bool operator > ( const reverse_iterator&)const;

      bool operator <= ( const reverse_iterator&)const;
      bool operator >= ( const reverse_iterator&)const;

      reverse_iterator operator + (int) const;
      reverse_iterator operator - (int) const;

      reverse_iterator& operator += (int);
      reverse_iterator& operator -= (int);
    };

    class  const_reverse_iterator {
      public:
      const_reverse_iterator(const const_reverse_iterator&);
      const_reverse_iterator();
      const_reverse_iterator& operator=(const const_reverse_iterator&);

      const T* operator -> ();

      const T& operator * ();

      const_reverse_iterator& operator ++ ();
      const_reverse_iterator& operator ++ (int);

      const_reverse_iterator& operator -- ();
      const_reverse_iterator& operator -- (int);

      bool operator == ( const const_reverse_iterator&)const;
      bool operator != ( const const_reverse_iterator&)const;

      bool operator < ( const const_reverse_iterator&)const;
      bool operator > ( const const_reverse_iterator&)const;

      bool operator <= ( const const_reverse_iterator&)const;
      bool operator >= ( const const_reverse_iterator&)const;

      const_reverse_iterator operator + (int) const;
      const_reverse_iterator operator - (int) const;

      const_reverse_iterator& operator += (int);
      const_reverse_iterator& operator -= (int);
    };

    typedef int size_type;
    typedef int difference_type;
    typedef T value_type;

    // construct/copy/destroy:
    explicit deque(): buf() { }
    explicit deque(size_type n){
    	buf = vector<T>(n);
    }
    explicit deque(size_type n, const T& value){
    	buf = vector<T>(n, value);
    }
    explicit deque(T t[], T* addr): buf()
    {         
        buf = vector<T>(t, addr);
    }
    deque(const deque<T>& x){
    	buf = x.buf;
    }
    ~deque();

    deque<T>& operator=(const deque<T>& x){
    	buf = x.buf;
    	return *this;
    }

    void assign(size_type n, const T& t){
    	buf.assign(n, t);
    }

    void assign(iterator first, iterator last){
    	buf.assign(first.it, last.it);
    }

    void assign(T n[], T* addr){
    	buf.assign(n, addr);
    }

    // iterators:
    iterator begin(){
    	return iterator(buf.begin());
    }
//    const_iterator begin() const;
    iterator end(){
    	return iterator(buf.end());
    }
/*    const_iterator end() const;
    reverse_iterator rbegin(){
    	return iterator(buf.rbegin());
    }
    const_reverse_iterator rbegin() const;
    reverse_iterator rend(){
    	return iterator(buf.rend());
    }
    const_reverse_iterator rend() const;
*/
    // capacity:
    size_type size() const
    {
    	return buf.size();
    }
    size_type max_size() const;
    void resize(size_type sz){
    	buf.resize(sz);
    }
    void resize(size_type sz, T c){
    	buf.resize(sz, c);
    }

    bool empty() const
    {
    	return buf.empty();
    }

    // element access:
    reference operator[](size_type i)
    {
    	return buf[i];
    }
    const_reference operator[](size_type i) const
    {
    	return buf[i];
    }
    void push_front(const T& x) {
    	buf.insert(buf.begin(), x);
    }
    void push_back(const T& x)  {
    	buf.push_back(x);
    }
    reference back()
    {
        return buf[buf.size()-1];
    }
    void pop_front(){
    	buf.erase(buf.begin());
    }
    void pop_back(){
    	buf.pop_back();
    }
    reference front()
    {
        return buf[0];
    }

    reference at(size_type n){
    	return buf.at(n);
    }
    const_reference at(size_type n) const{
    	return buf.at(n);
    }

    const_reference front() const
    {
        return buf[0];
    }

    const_reference back() const
    {
        return buf[buf.size()-1];
    }

    // modifiers:
    iterator insert(iterator position, const T& x){
    	return iterator(buf.insert(position.it, x));
    }
    void insert(iterator position, size_type n, const T& x){
    	buf.insert(position.it, n, x);
    }

    iterator erase(iterator position){
    	return iterator(buf.erase(position.it));
    }
    iterator erase(iterator first, iterator last){
    	return iterator(buf.erase(first.it, last.it));
    }

    void swap(deque<T>& d){
    	buf.swap(d.buf);
    }
    void clear(){
    	buf.clear();
    }

    // comparators:
    /*
    bool operator == (const deque<T> d) const{
    	return (buf == d.buf);
    }
    bool operator != (const deque<T> d) const;
    bool operator >= (const deque<T> d) const;
    bool operator <= (const deque<T> d) const;
*/
    public:
    	vector<T> buf;
  };

//template<class T>
//  bool deque<T>::operator!= (const deque<T> d) const{
//	  return (this->buf != d.buf);
//  }
//template<class T>
//  bool deque<T>::operator>= (const deque<T> d) const{
//	  return (this->buf >= d.buf);
//  }
//template<class T>
//  bool deque<T>::operator<= (const deque<T> d) const{
//	  return (this->buf <= d.buf);
//  }

}
#endif

