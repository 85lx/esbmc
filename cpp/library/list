#ifndef __STL_LIST
#define __STL_LIST

#include "iterator"

namespace std {

  template <class T>
  class list {
    public:
    // types:
    typedef T& reference;
    typedef const T& const_reference;
    typedef int size_type;
    typedef int difference_type;
    typedef T value_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    
    // construct/copy/destroy:
    explicit list();
    explicit list(size_type n, const T&);
    explicit list(size_type n);

    list(const list<T>& x);
    ~list();

    list<T>& operator=(const list<T>& x);
    void assign(size_type n, const T& t);

    // iterators:
    iterator begin();
    const_iterator begin() const;
    iterator end();
    const_iterator end() const;
    reverse_iterator rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator rend();
    const_reverse_iterator rend() const;

    // capacity:
    bool empty() const;
    size_type size() const;
    size_type max_size() const;
    void resize(size_type sz);
    void resize(size_type sz, T t);

    // element access:
    reference front();
    const_reference front() const;
    reference back();
    const_reference back() const;

    // modifiers:
    void push_front(const T& x);
    void pop_front();
    void push_back(const T& x);
    void pop_back();

    iterator insert(iterator position, const T& x);
    void insert(iterator position, size_type n, const T& x);

    iterator erase(iterator position);
    iterator erase(iterator position, iterator last);
    void swap(list<T>&);
    void clear();

    // list operations:
    void splice(iterator position, list<T>& x);
    void splice(iterator position, list<T>& x, iterator i);
    void splice(iterator position, list<T>& x, iterator first, iterator last);
    void remove(const T& value);

    void unique();
    void merge(list<T>& x);
    void sort();
    void reverse();
  };

}

#endif
