/*******************************************************************\

Module: 

Author: 

Date: Feb 2012

\*******************************************************************/

#ifndef __STL_VECTOR
#define __STL_VECTOR

#include "iterator"
#include "stdexcept"

#define VECTOR_CAPACITY 500

namespace std{

template<class T>
class vector{
public:

	class iterator{
	public:
		T* pointer;
		int pos;
		T* vec_pos;

		iterator(const iterator& i)
		{
			pointer = i.pointer;
			pos = i.pos;
		}
		iterator(){

		}
		iterator(T* p){
			pointer = p;
		}
		iterator& operator=(const iterator& i){
			pointer = i.pointer;
			pos = i.pos;
			return *this;
		}

		T* operator -> ();

		T& operator * (){
			return *pointer;
		}

		iterator& operator ++ (){
			iterator buffer;
			buffer.pointer = pointer;
			buffer.pos = pos;
			pointer++;
			pos++;
			return buffer;
		}
		iterator& operator ++ (int b){
			iterator buffer;
			pointer++;
			pos++;
			buffer.pointer = pointer;
			buffer.pos = pos;
			return buffer;
		}

		iterator& operator -- (){
			iterator buffer;
			buffer.pointer = pointer;
			buffer.pos = pos;
			pointer--;
			pos--;
			return buffer;
		}
		iterator& operator -- (int b){
			iterator buffer;
			pointer--;
			pos--;
			buffer.pointer = pointer;
			buffer.pos = pos;
			return buffer;
		}

		bool operator == ( const iterator& i)const{
			return (pointer == i.pointer);
		}
		bool operator != ( const iterator& i)const{
			return (pointer != i.pointer);
		}

		bool operator < ( const iterator& i)const{
			return (pointer < i.pointer);
		}
		bool operator > ( const iterator& i)const{
			return (pointer > i.pointer);
		}


		bool operator <= ( const iterator&)const;
		bool operator >= ( const iterator&)const;

		iterator operator + (int n) const{
			iterator buffer;
			buffer.pointer = pointer + sizeof(T) * n;
			buffer.pos = pos + n;
			return buffer;
		}
		iterator operator - (int) const;
		iterator operator - (const iterator&) const;

		iterator& operator += (int);
		iterator& operator -= (int);
	};

	class const_iterator
	{
	public:
		T* pointer;
		int pos;
		T* vec_pos;

		const_iterator(const const_iterator& i)
		{
			pointer = i.pointer;
		}
		const_iterator(){

		}
		const_iterator(T* p){
			pointer = p;
		}
		const_iterator& operator=(const const_iterator& i){
			pointer = i.pointer;
		}

		T* operator -> ();

		T& operator * (){
			return *pointer;
		}

		const_iterator& operator ++ (){
			const_iterator buffer;
			buffer.pointer = pointer;
			buffer.pos = pos;
			pointer ++;
			pos++;
			return buffer;
		}
		const_iterator& operator ++ (int b){
			const_iterator buffer;
			pointer ++;
			pos++;
			buffer.pointer = pointer;
			buffer.pos = pos;
			return buffer;
		}

		const_iterator& operator -- ();
		const_iterator& operator -- (int);

		bool operator == ( const const_iterator& i)const{
			return (pointer == i.pointer);
		}
		bool operator != ( const const_iterator& i)const{
			return ((pointer < i.pointer)||(pointer > i.pointer));
		}

		bool operator < ( const const_iterator& i)const{
			return (pointer < i.pointer);
		}
		bool operator > ( const const_iterator& i)const{
			return (pointer > i.pointer);
		}

		bool operator <= ( const const_iterator&)const;
		bool operator >= ( const const_iterator&)const;

		const_iterator operator + (int) const;
		const_iterator operator - (int) const;
		const_iterator operator - (const const_iterator&) const;

		const_iterator& operator += (int);
		const_iterator& operator -= (int);
	};

	class reverse_iterator{
	public:
		T* pointer;
		int pos;
		T* vec_pos;
		reverse_iterator(const reverse_iterator& i){
			pointer = i.pointer;
			pos = i.pos;
			vec_pos = i.vec_pos;
		}
		reverse_iterator(){

		}
		reverse_iterator& operator=(const reverse_iterator& i){
			pointer = i.pointer;
			pos = i.pos;
			vec_pos = i.vec_pos;
			return *this;
		}

		T* operator -> ();

		T& operator * (){
			return *pointer;
		}

		reverse_iterator& operator ++ ();
		reverse_iterator& operator ++ (int n){
			reverse_iterator buffer;
			buffer.pointer = pointer;
			buffer.pos = pos;
			buffer.vec_pos = vec_pos;
			pointer -= sizeof(T);
			pos--;
			return buffer;
		}

		reverse_iterator& operator -- ();
		reverse_iterator& operator -- (int);

		bool operator == ( const reverse_iterator&)const;
		bool operator != ( const reverse_iterator&)const;

		bool operator < ( const reverse_iterator&)const;
		bool operator > ( const reverse_iterator&)const;

		bool operator <= ( const reverse_iterator&)const;
		bool operator >= ( const reverse_iterator&)const;

		reverse_iterator operator + (int) const;
		reverse_iterator operator - (int) const;

		reverse_iterator& operator += (int);
		reverse_iterator& operator -= (int);
	};

	class  const_reverse_iterator {
	public:
		const_reverse_iterator(const const_reverse_iterator&);
		const_reverse_iterator();
		const_reverse_iterator& operator=(const const_reverse_iterator&);

		const T* operator -> ();

		const T& operator * ();

		const_reverse_iterator& operator ++ ();
		const_reverse_iterator& operator ++ (int);

		const_reverse_iterator& operator -- ();
		const_reverse_iterator& operator -- (int);

		bool operator == ( const const_reverse_iterator&)const;
		bool operator != ( const const_reverse_iterator&)const;

		bool operator < ( const const_reverse_iterator&)const;
		bool operator > ( const const_reverse_iterator&)const;

		bool operator <= ( const const_reverse_iterator&)const;
		bool operator >= ( const const_reverse_iterator&)const;

		const_reverse_iterator operator + (int) const;
		const_reverse_iterator operator - (int) const;

		const_reverse_iterator& operator += (int);
		const_reverse_iterator& operator -= (int);
	};

	// types:
	typedef T& reference;
	typedef const T& const_reference;
	typedef int size_type;
	typedef int difference_type;
	typedef T value_type;
	typedef T* pointer;
	typedef const T* const_pointer;

	// construct:
	explicit vector(): _size(0), _capacity(1)
	{
		buf[0] = 0;
		buf[1] = 0;
		_size = 0;
		_capacity = 1;
	}

	//    explicit vector(T t1, T t2): _size(0)
	//    {
		//       push_back(t1);
		//			 push_back(t2);
		//    }

	explicit vector(iterator t1, iterator t2): _size(0)
	{
		//model
	}

//	explicit vector(T t): _size(0)
//	{
//		buf[0] = 0;
//		_size = 0;
//		_capacity = 1;
//		push_back(t);
//		verify_capacity();
//	}

	explicit vector(size_type n): _size(0),  _capacity(1)
	{
		_size = n;
		_capacity = n;
	}

	explicit vector(void t[], void* addr): _size(0),  _capacity(1)
	{
		int i=0;
		T* t1 = (T*) t;
		T* addr1 = (T*) addr;
		while((t1+i)<addr1)
			push_back(t1[i++]);
		verify_capacity();
	}

	explicit vector ( size_type n, const T& x)
	{
		_size = 0;
		buf[0] = 0;
		for(int i = 0; i < n; i++)
			push_back(x);
		verify_capacity();
	}

	vector(const vector<T>& x): _size(0),  _capacity(1)
	{
		//model
	}

	vector<T>& operator=(const vector<T>& x){
		_size = 0;
		//*buf = 0;
		for(int i = 0 ; i < x.size() ; i++)
			push_back(x[i]);
		verify_capacity();
	}
	//void assign ( T first, T last );
	void assign(size_type n, const T& u){
		_size = 0;
		buf[0] = 0;
		for(int i = 0; i < n; i++)
			push_back(u);
		verify_capacity();
	}
//	void assign(int t1, int t2);
	void assign(iterator t1, iterator t2){
		int n = 1;
		for(n = 1 ; t1 != t2 ; t1++){
			buf[n++] = *t1;
		}
		_size = n;
		verify_capacity();
	}
	void assign(void t1[], void *t2){
		int i=0;
		_size = 0;
		T* t11 = (T*) t1;
		T* t21 = (T*) t2;
		while((t11+i)<t21)
			push_back(t11[i++]);
		verify_capacity();
	}

	// iterators:
	iterator begin(){
		iterator buffer;
		buffer.pointer = buf + 1;
		buffer.pos = 1;
		buffer.vec_pos = buf;
		return buffer;
	}
	const_iterator begin() const{
		const_iterator buffer;
		buffer.pointer = buf + 1;
		buffer.pos = 1;
		buffer.vec_pos = buf;
		return buffer;
	}
	iterator end(){
		iterator buffer;
		int n = _size + 1;
		buf[n] = 0;
		buffer.pointer = &(buf[n]);
		buffer.pos = _size + 1;
		buffer.vec_pos = buf;
		return buffer;
	}
	const_iterator end() const{
		const_iterator buffer;
		int n = _size + 1;
		buf[n] = 0;
		buffer.pointer = &(buf[n]);
		buffer.pos = _size + 1;
		buffer.vec_pos = buf;
		return buffer;
	}
	reverse_iterator rbegin(){
		reverse_iterator buffer;
		buffer.pointer = buf + _size;
		buffer.pos = _size;
		buffer.vec_pos = buf;
		return buffer;
	}
	const_reverse_iterator rbegin() const;
	reverse_iterator rend(){
		reverse_iterator buffer;
		buf[0] = 0;
		buffer.pointer = buf;
		buffer.pos = 0;
		buffer.vec_pos = buf;
		return buffer;
	}
	const_reverse_iterator rend() const;

	// capacity:
	size_type size() const
	{
		assert(0 <= _size );
		assert(_size <= VECTOR_CAPACITY);
		return _size;
	}

	size_type max_size() const;

	void resize(size_type sz){
		_size = sz;
		verify_capacity();
	}
	void resize(size_type sz, T t){
		if(sz < _size){
			_size = sz;
			return;
		}
		while(_size < sz){
			push_back(t);
		}
		verify_capacity();
		return;
	}
	size_type capacity() const
	{
		assert(0 <= _size && _size <= _capacity);
		return _capacity;
	}

	bool empty() const
	{
		return (_size == 0) ? true : false;
	}

	void reserve(size_type n){
		_capacity = n;
	}

	// element access:
	reference operator[](size_type i)
	{
		assert(0 <= i);
		assert(i < _size);
		assert(_size <= VECTOR_CAPACITY);
		i++;
		return buf[i];
	}

	const_reference operator[](size_type i) const
	{
		assert(0 <= i);
		assert(i < _size);
		assert(_size <= VECTOR_CAPACITY);
		i++;
		return buf[i];
	}

	const_reference at(size_type n) const{
		assert(0 <= n);
		assert(n < _size);
		assert(_size <= VECTOR_CAPACITY);
		return buf[n + 1];
	}
	reference at(size_type n){
		assert(0 <= n);
		assert(n < _size);
		assert(_size <= VECTOR_CAPACITY);
		return buf[n + 1];
	}
	reference front(){
		return buf[1];
	}
	const_reference front() const{
		return buf[1];
	}

	value_type back()
	{
		return buf[_size];
	}

	const_reference back() const{
		return buf[_size];
	}

	// modifiers:
	void push_back(const T& x)
	{
		assert(0 <= _size);
		assert(_size < VECTOR_CAPACITY);
		_size++;
		buf[_size] = x;
		int n = _size + 1;
		buf[n] = 0;
		verify_capacity();
	}
	void verify_capacity(){
		while(_size >= _capacity) _capacity *= 2;
	}
	void pop_back()
	{
		__ESBMC_assert(_size!=0, "pop_back() on empty vector");
		buf[_size] = 0;
		_size--;
	}

	iterator insert(iterator position, const T& x){
		_size++;
		buf[_size] = 0;
		iterator i = end() - 2;
		while(i != position - 1){
			*(i + 1) = *(i--);
		}
		buf[position.pos] = x;
		verify_capacity();
		return position;
	}
	void insert(iterator position, size_type n, const T& x){
		for(int j = 0 ; j < n ; j++){
			_size++;
			iterator i = end() - 2;
			while(i != position - 1){
				*(i + 1) = *(i--);
			}
			*position = x;
		}
		verify_capacity();
		buf[_size + 1] = 0;
	}
	void insert(iterator position, iterator first, iterator last){
		for(iterator j = last - 1 ; j == first ; j--){
			_size++;
			iterator i = end() - 2;
			while(i != position - 1){
				*(i + 1) = *(i--);
			}
			*position = *j;
		}
		buf[_size + 1] = 0;
		verify_capacity();
	}
	void insert(iterator position, T n[], T* x){
		int j = 0;
		while((n+j)<x)
			insert(position + j, n[j++]);
		buf[_size + 1] = 0;
		verify_capacity();
	}

	iterator erase(iterator position){
		for(int i = position.pos + 1; i < _size ; i++){
			buf[i - 1] = buf[i];
		}
		_size--;
		buf[_size + 1] = 0;
		verify_capacity();
		return position;
	}
	iterator erase(iterator first, iterator last);

	void swap(vector<T>&);
	void clear(){
		_size = 0;
		buf[0] = 0;
		buf[1] = 0;
		return;
	}

	// comparators:

	bool operator == (const vector<T>&) const: _size(0)
	{/*
		__ESBMC_HIDE:
	    if(vtr._size != v2._size)return false;
   	      for(unsigned i = 0; i < vtr._size; i++)
   	        if (vtr.buf[i] != v2.buf[i]) return false;
		return true;
	 */}
	bool operator != (const vector<T>&) const: _size(0)
			{/*
		__ESBMC_HIDE:
	    return !(vtr==v2);
			 */}
	bool operator >= (const vector<T>&) const;
	bool operator <= (const vector<T>&) const;

private:
	T buf[VECTOR_CAPACITY];
	int _size;
	int _capacity;

};

// specialized algorithms:

template <class T>
void swap(vector<T>& v1){
	//	  T aux[VECTOR_CAPACITY];
	//
	//	  for(int i = 0 ; i < v1.size() ; i++){
	//		  aux[i] = v1[i];
	//	  }
	//	  v1.clear();
	//	  for(int i = 0 ; i < v2.size() ; i++){
	//		  v1.push_back(v2[i]);
	//	  }
	//	  v2.clear();
	//	  for(int i = 0 ; i < v1.size() ; i++){
	//		  v2.push_back(aux[i]);
	//	  }
	//	  return;
	assert(0);
}

}

#endif

