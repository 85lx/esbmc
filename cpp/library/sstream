#ifndef STL_SSTREAM
#define STL_SSTREAM

#include "streambuf"
#include "definitions.h"
#include "ostream"
#include "ios"
#include "string"
#include "cstdio"


namespace std
{
class stringbuf: public streambuf{
public:
	explicit stringbuf ( ios_base::openmode which = ios_base::in | ios_base::out );
	explicit stringbuf ( const string& str, ios_base::openmode which = ios_base::in | ios_base::out );
	void str ( const string & s );
	string str ( ) const;
//	Virtual protected members
protected:
	streambuf* setbuf ( char* s, streamsize n);
	streampos seekoff ( streamoff off, ios_base::seekdir way, ios_base::openmode which = ios_base::in | ios_base::out );
	streampos seekpos ( streampos sp, ios_base::openmode which = ios_base::in | ios_base::out );
	int underflow ( );
	int pbackfail ( int c = EOF );
	int overflow ( int c = EOF );

};

class istringstream:public istream{
public:
	explicit istringstream ( openmode which = ios_base::in ){istream();}
	explicit istringstream ( const string & str, openmode which = ios_base::in ){istream();}
	stringbuf* rdbuf ( ) const;
	string str ( ) const;
	void str ( const string & s );
//	explicit istringstream ( const string & str );
//	istream& operator>> (string& val );
//	istream& operator>> (int& val );
//	bool good ( ) const;
};

class stringstream:public istream, public ostream{
public:
	string _string;
	explicit stringstream ( openmode which = ios_base::out|ios_base::in ) {istream();ostream();}
	explicit stringstream ( const string & str, openmode which = ios_base::out|ios_base::in ) {istream();ostream();}
	stringbuf* rdbuf ( ) const;
	string str ( ) const{
		return _string;
	}
	//void str ( const string & s );
	ostream& operator<< (string& val) {
		ostream m;
		_string.append(val);
		return m;
	}

	ostream& operator<< (bool& val) {
		char temp;
		if(val)
			_string.append("1");
		else
			_string.append("0");

		ostream m;
		return m;

	}
/*
	ostream& operator<< (int& val) {
		_string.clear();
		_string = val;
	}

	ostream& operator<< (unsigned int& val) {
		_string.clear();
		_string = val;
	}

	ostream& operator<< (long& val) {
		_string.clear();
		_string = val;
	}

	ostream& operator<< (unsigned long& val) {
		_string.clear();
		_string = val;
	}

	ostream& operator<< (float& val) {
		_string.clear();
		_string = val;
	}

	ostream& operator<< (double& val) {
		_string.clear();
		_string = val;
	}

	ostream& operator<< (long double& val) {
		_string.clear();
		_string = val;
	}

	ostream& operator<< (void*& val) {
		_string.clear();
		_string = val;
	}

	ostream& operator<< (char& val) {
		_string.clear();
		_string = val;
	}

	ostream& operator<< (signed char& val) {
		_string.clear();
		_string = val;
	}

	ostream& operator<< (unsigned char& val) {
		_string.clear();
		_string = val;
	}

	ostream& operator<< (char*& val) {
		_string.clear();
		_string = val;
	}

	ostream& operator<< (signed char*& val) {
		_string.clear();
		_string = val;
	}

	ostream& operator<< (unsigned char*& val) {
		_string.clear();
		_string = val;
	}


	*/
};

class ostringstream:public ostream{
public:
	explicit ostringstream ( openmode which = out ){ostream();}
	explicit ostringstream ( const string & str, openmode which = out ){ostream();}
	stringbuf* rdbuf ( ) const;
	string str ( ) const;
	void str ( const string & s );
//	ostream& operator<< (string& val );
//	ostream& operator<< (int &val);
//	ostream& operator<< (int val);
//	ostream& operator<< (double val);
//	ostream& operator<< (const char* s );
};

}

#endif
