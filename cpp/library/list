/*******************************************************************
 Module:

 Author: Felipe Rodrigues

 Date: October 2012

 \*******************************************************************/

#ifndef __STL_LIST
#define __STL_LIST

//#include "iterator"

namespace std {

template<class T>
class list {
public:
	typedef T& reference;
	typedef const T& const_reference;
	typedef int size_type;
	typedef int difference_type;
	typedef T value_type;
	typedef T* pointer;
	typedef const T* const_pointer;

	struct node {
		T data;
		node* prev;
		node* next;
		node(T t, node* p, node* n) :
				data(t), prev(p), next(n) {
		}
	};

	node* head;
	node* tail;
	int _size;

	class iterator {
	public:
		node* it;
		int it_size;

		iterator(const iterator& x): it(x.it), it_size(x.it_size){}
		iterator(): it(NULL), it_size(0){}
		iterator& operator=(const iterator& x){
			this->it = x.it;
			this->it_size = x.it_size;
			return *this;
		}

		T* operator ->();

		T operator *(){
			return this->it->data;
		}

		iterator operator ++(){ //error
			this->it = this->it->next;
			return *this;
		}
		iterator operator ++(int){ //error
			this->it = this->it->next;
			return *this;
		}

		iterator operator --(){
			this->it = this->it->prev;
			return *this;
		}
		iterator& operator --(int){
			this->it = this->it->prev;
			return *this;
		}

		bool operator ==(const iterator& x) const{
			return (x.it == this->it && x.it_size == this->it_size);
		}
		bool operator !=(const iterator& x) const{
			return (x.it != this->it && x.it_size != this->it_size);
		}

		bool operator <(const iterator&) const;
		bool operator >(const iterator&) const;

		bool operator <=(const iterator&) const;
		bool operator >=(const iterator&) const;

		iterator operator +(int) const;
		iterator operator -(int) const;

		iterator& operator +=(int);
		iterator& operator -=(int);
	};

	class reverse_iterator {
	public:
		node* it;
		int it_size;

		reverse_iterator(const reverse_iterator& x): it(x.it), it_size(x.it_size){}

		reverse_iterator(): it(NULL), it_size(0){}
		reverse_iterator& operator=(const reverse_iterator& x){
			this->it = x.it;
			this->it_size = x.it_size;
			return *this;
		}

		T* operator ->();

		T operator *(){
			return this->it->data;
		}

		reverse_iterator operator ++(){ //error
			this->it = this->it->next;
			return *this;
		}
		reverse_iterator operator ++(int){ //error
			this->it = this->it->next;
			return *this;
		}

		reverse_iterator operator --(){
			//this->it = this->it->prev;
			assert(this->it->data == 1);
			return *this;
		}
		reverse_iterator& operator --(int){
			this->it = this->it->prev;
			return *this;
		}

		bool operator ==(const reverse_iterator& x) const{
			return (x.it == this->it && x.it_size == this->it_size);
		}
		bool operator !=(const reverse_iterator& x) const{
			return (x.it != this->it && x.it_size != this->it_size);
		}

		bool operator <(const reverse_iterator&) const;
		bool operator >(const reverse_iterator&) const;

		bool operator <=(const reverse_iterator&) const;
		bool operator >=(const reverse_iterator&) const;

		reverse_iterator operator +(int) const;
		reverse_iterator operator -(int) const;

		reverse_iterator& operator +=(int);
		reverse_iterator& operator -=(int);
	};

	explicit list() : head(NULL), tail(NULL), _size(0) {}
	explicit list ( size_type n, const T& value = T() ){
		int i;
		this->_size = 0;
		for(i=0; i<n; i++)
			this->push_back(value);
	}
	explicit list (T* t1, T* t2){
		this->_size = 0;
		for(; t1!=t2; t1++)
			this->push_back(*t1);
	}
	list ( iterator first, iterator last) : head(first.it), tail(last.it), _size(first.it_size) {}
	list(const list<T>& x) : head(x.head), tail(x.tail), _size(x._size) {}

	~list() {
		while (head) {
			node* temp(head);
			head = head->next;
			delete temp;
		}
	}

	iterator begin (){
		iterator it;
		it.it = new node(this->head->data, this->head->prev, this->head->next);
		it.it_size = this->_size;
		return it;
	}
	iterator end (){
		iterator it;
		it.it = new node(this->tail->data, this->tail->prev, this->tail->next);
		it.it_size = this->_size;
		return it;
	}
	reverse_iterator rbegin(){
		reverse_iterator it;
		it.it = new node(this->tail->data, this->tail->prev, this->tail->next);
		it.it_size = this->_size;
		return it;
	}
	reverse_iterator rend(){
		reverse_iterator it;
		it.it = new node(this->head->data, this->head->prev, this->head->next);
		it.it_size = this->_size;
		return it;
	}

	size_type size() const{
		return this->_size;
	}
	bool empty ( ) const{
		if (this->_size == 0)
			return true;
		return false;
	}
	size_type max_size () const{
		return this->_size;
	}
	void resize ( size_type sz, T c = T() ){
		int i;
		int tmp_int;
		if(this->_size > sz){
			tmp_int = this->_size - sz;
			for(i=0;i<tmp_int;i++){
				this->tail = this->tail->prev;
				this->tail->next = NULL;
			}
		}else{
			tmp_int = sz - this->_size;
			for(i=0;i<tmp_int;i++){
				this->push_back(c);
			}
		}
	}
    T back ( ){
    	__ESBMC_assert(!empty(), "list is empty");
    	return this->tail->data;
    }
    T front ( ){
    	__ESBMC_assert(!empty(), "list is empty");
    	return this->head->data;
    }
	void pop_front(){
		__ESBMC_assert(!empty(), "list is empty");
		this->_size--;
		if (this->head == this->tail){
			this->head = this->tail = NULL;
		}else{
			this->head = new node(this->head->data, this->head->prev, this->head->next);
		}
	}
	void pop_back ( ){
		__ESBMC_assert(!empty(), "list is empty");
		if (this->_size == 1){
			this->head = this->tail = NULL;
		}else{
			this->tail = new node(this->tail->prev->data, this->tail->prev->prev, NULL);
		}
		this->_size--;
	}
	void push_back ( const T& x ){
		if(this->empty()){
			this->tail = new node(x, NULL, NULL);
			this->head = this->tail;
		}else{
			this->tail->next = new node(x, this->tail, NULL);
			this->tail = this->tail->next;
		}
		this->_size++;
	}
	void push_front ( const T& x ){
		if(this->empty()){
			this->head = new node(x, NULL, NULL);
			this->tail = this->head;
		}else{
			this->head->prev = new node(x, NULL, this->head);
			this->head = this->head->prev;
		}
		this->_size++;
	}

	iterator insert(iterator position, const T& x);
	void insert(iterator position, size_type n, const T& x);

	void assign ( iterator first, iterator last ){
		this->head = first.it;
		this->_size = first.it_size;
		this->tail = last.it;
	}
	void assign ( T* first, T* last ){
		list <T> list (first, last);
		this->head = list.head;
		this->_size = list._size;
		this->tail = list.tail;
	}
	void assign ( size_type n, const T& u ){
		list <T> list (n, u);
		this->head = list.head;
		this->_size = list._size;
		this->tail = list.tail;
	}

	iterator erase(iterator position);
	iterator erase(iterator position, iterator last);
	void swap(list<T>&);
	void clear();

	// list operations:
	void splice(iterator position, list<T>& x);
	void splice(iterator position, list<T>& x, iterator i);
	void splice(iterator position, list<T>& x, iterator first, iterator last);
	void remove(const T& value);
	template <class Predicate>
	  void remove_if ( Predicate pred );

	void unique();
	void merge(list<T>& x);
	void sort();
	void reverse();
};

  bool operator== ( const list<int>& x, const list<int>& y ){
	  return (x._size == y._size && x.head == y.head && x.tail == y.tail);
  }
  bool operator!= ( const list<int>& x, const list<int>& y ){
	  return (x._size != y._size && x.head != y.head && x.tail != y.tail);
  }

}

#endif
