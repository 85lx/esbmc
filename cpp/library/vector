/*******************************************************************\

Module: 

Author: 

Date: Feb 2012

\*******************************************************************/

#ifndef __STL_VECTOR
#define __STL_VECTOR

#include "iterator"

#define VECTOR_CAPACITY 30

namespace std{

  template<class T>
  class vector{
    public:

	    class iterator{
	      public:
	    	T* pointer;
	    	int pos;

	    	iterator(const iterator& i)
	    	{
	    		pointer = i.pointer;
	    	}
	    	iterator(){

	    	}
	    	iterator(T* p){
	    		pointer = p;
	    	}
	    	iterator& operator=(const iterator& i){
	    		pointer = i.pointer;
	    	}

	      T* operator -> ();

	      T& operator * ();

	      iterator& operator ++ ();
	      iterator& operator ++ (int);

	      iterator& operator -- ();
	      iterator& operator -- (int);

	      bool operator == ( const iterator&)const;
	      bool operator != ( const iterator&)const;

	      bool operator < ( const iterator&)const;
	      bool operator > ( const iterator&)const;

	      bool operator <= ( const iterator&)const;
	      bool operator >= ( const iterator&)const;

	      iterator operator + (int) const;
	      iterator operator - (int) const;
	      iterator operator - (const iterator&) const;

	      iterator& operator += (int);
	      iterator& operator -= (int);
	    };

	    class const_iterator
	    {
	      public:
	      const_iterator(const const_iterator&);
	      const_iterator();
	      const_iterator& operator=(const const_iterator&);

	      const T* operator -> ();

	      const T& operator * ();

	      const_iterator& operator ++ ();
	      const_iterator& operator ++ (int);

	      const_iterator& operator -- ();
	      const_iterator& operator -- (int);

	      bool operator == ( const const_iterator&)const;
	      bool operator != ( const const_iterator&)const;

	      bool operator < ( const const_iterator&)const;
	      bool operator > ( const const_iterator&)const;

	      bool operator <= ( const const_iterator&)const;
	      bool operator >= ( const const_iterator&)const;

	      const_iterator operator + (int) const;
	      const_iterator operator - (int) const;

	      const_iterator& operator += (int);
	      const_iterator& operator -= (int);
	    };

	    class reverse_iterator{
	      public:
	      reverse_iterator(const reverse_iterator&);
	      reverse_iterator();
	      reverse_iterator& operator=(const reverse_iterator&);

	      T* operator -> ();

	      T& operator * ();

	      reverse_iterator& operator ++ ();
	      reverse_iterator& operator ++ (int);

	      reverse_iterator& operator -- ();
	      reverse_iterator& operator -- (int);

	      bool operator == ( const reverse_iterator&)const;
	      bool operator != ( const reverse_iterator&)const;

	      bool operator < ( const reverse_iterator&)const;
	      bool operator > ( const reverse_iterator&)const;

	      bool operator <= ( const reverse_iterator&)const;
	      bool operator >= ( const reverse_iterator&)const;

	      reverse_iterator operator + (int) const;
	      reverse_iterator operator - (int) const;

	      reverse_iterator& operator += (int);
	      reverse_iterator& operator -= (int);
	    };

	    class  const_reverse_iterator {
	      public:
	      const_reverse_iterator(const const_reverse_iterator&);
	      const_reverse_iterator();
	      const_reverse_iterator& operator=(const const_reverse_iterator&);

	      const T* operator -> ();

	      const T& operator * ();

	      const_reverse_iterator& operator ++ ();
	      const_reverse_iterator& operator ++ (int);

	      const_reverse_iterator& operator -- ();
	      const_reverse_iterator& operator -- (int);

	      bool operator == ( const const_reverse_iterator&)const;
	      bool operator != ( const const_reverse_iterator&)const;

	      bool operator < ( const const_reverse_iterator&)const;
	      bool operator > ( const const_reverse_iterator&)const;

	      bool operator <= ( const const_reverse_iterator&)const;
	      bool operator >= ( const const_reverse_iterator&)const;

	      const_reverse_iterator operator + (int) const;
	      const_reverse_iterator operator - (int) const;

	      const_reverse_iterator& operator += (int);
	      const_reverse_iterator& operator -= (int);
	    };

    // types:
    typedef T& reference;
    typedef const T& const_reference;
    typedef int size_type;
    typedef int difference_type;
    typedef T value_type;
    typedef T* pointer;
    typedef const T* const_pointer;

    // construct:
    explicit vector(): _size(0), _capacity(0)
    {

    }

//    explicit vector(T t1, T t2): _size(0)
//    {
//       push_back(t1);
//			 push_back(t2);
//    }

    explicit vector(iterator t1, iterator t2): _size(0)
    {
				//model
    }

    explicit vector(T t): _size(0)
    {
			push_back(t);
    }

    explicit vector(T t[], T* addr): _size(0),  _capacity(0)
    {
        int i=0;
				while((t+i)<addr)
          push_back(t[i++]);
    }

   explicit vector ( size_type n, const T& value= T())
   {
      _size=n;
			//model
   }

    vector(const vector<T>& x): _size(0),  _capacity(0)
    {
        //model
    }

    vector<T>& operator=(const vector<T>& x){
    	_size = 0;
    	for(int i = 0 ; i < x.size() ; i++){
    		push_back(x[i]);
    	}
    }
    //void assign ( T first, T last );
    //void assign(size_type n, const T& u);
    void assign(int t1, int t2);
    void assign(iterator t1, iterator t2){
    	iterator p;
    	int n;
    	for(p = t1, n = 0 ; p != t2 ; p++, n++){
    		buf[n] = *p;
    	}
    	_size = n;
    	return;
    }
    void assign(int t1[], int *t2);

    // iterators:
    iterator begin(){
    	iterator buffer;
    	buffer.pointer = buf;
    	buffer.pos = 0;
    	return buffer;
    }
    const_iterator begin() const;
    iterator end(){
    	iterator buffer;
    	buffer.pointer = (buf + _size - 1);
    	buffer.pos = _size - 1;
    	return buffer;
    }
    const_iterator end() const;
    reverse_iterator rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator rend();
    const_reverse_iterator rend() const;

    // capacity:
    size_type size() const
    {
			assert(0 <= _size );
			assert(_size <= VECTOR_CAPACITY);
			return _size;
    }

    size_type max_size() const;

    void resize(size_type sz);
    void resize(size_type sz, T t);
    size_type capacity() const
    {
			assert(0 <= _size && _size <= VECTOR_CAPACITY);
			return VECTOR_CAPACITY;
    }

    bool empty() const
    {
			return (_size == 0) ? true : false;
    }

    void reserve(size_type n);

    // element access:
    reference operator[](size_type i)
    {
			assert(0 <= i);
			assert(i < _size);
			assert(_size <= VECTOR_CAPACITY);
			return buf[i];
    }

    const_reference operator[](size_type i) const
    {
			assert(0 <= i);
			assert(i < _size);
			assert(_size <= VECTOR_CAPACITY);
			return buf[i];
    }

    const_reference at(size_type n) const;
    reference at(size_type n);
    reference front(){
    	return buf[0];
    }
    const_reference front() const{
    	return buf[0];
    }

    value_type back()
    {      
      return buf[_size-1];
    }

    const_reference back() const{
    	return buf[_size-1];
    }

    // modifiers:
    void push_back(const T& x)
    {
			assert(0 <= _size);
			assert(_size < VECTOR_CAPACITY);
			buf[_size++] = x;
    }

    void pop_back()
    {
      __ESBMC_assert(_size!=0, "pop_back() on empty vector");
      _size--;
    }

    iterator insert(iterator position, const T& x);
    void insert(iterator position, size_type n, const T& x);
    void insert(iterator position, iterator n, iterator x){
   	    	// model
   	}
    void insert(iterator position, T n[], T* x){
  	    	// model
  	}

    iterator erase(iterator position){
    	for(int i = position.pos + 1; i < _size ; i++){
    		buf[i - 1] = buf[i];
    	}
    	_size--;
    	return position;
    }
    iterator erase(iterator first, iterator last);

    void swap(vector<T>&);
    void clear(){
    	_size = 0;
    	return;
    }

    // comparators:

    bool operator == (const vector<T>&) const: _size(0)
	{/*
		__ESBMC_HIDE:
	    if(vtr._size != v2._size)return false;
   	      for(unsigned i = 0; i < vtr._size; i++)
   	        if (vtr.buf[i] != v2.buf[i]) return false;
		return true;
	*/}
    bool operator != (const vector<T>&) const: _size(0)
	{/*
		__ESBMC_HIDE:
	    return !(vtr==v2);
	*/}
    bool operator >= (const vector<T>&) const;
    bool operator <= (const vector<T>&) const;

	private:
		T buf[VECTOR_CAPACITY];
		int _size;
		int _capacity;

};

  // specialized algorithms:

  template <class T>
  void swap(vector<T>& v1, vector<T>& v2){
	  T aux[VECTOR_CAPACITY];
	  for(int i = 0 ; i < v1.size() ; i++){
		  aux[i] = v1[i];
	  }
	  v1.clear();
	  for(int i = 0 ; i < v2.size() ; i++){
		  v1.push_back(v2[i]);
	  }
	  v2.clear();
	  for(int i = 0 ; i < v1.size() ; i++){
		  v2.push_back(aux[i]);
	  }
	  return;
  }

}

#endif
