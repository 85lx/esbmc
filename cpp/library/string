/*******************************************************************\

Module: 

Author: Felipe Rodrigues

Date: Feb 2012

\*******************************************************************/

#ifndef STL_STRING
#define STL_STRING

#include "definitions.h"
#include "cstring"
#include "ostream"
#include "istream"
#include "cassert"
#include "iostream"

size_t npos;

namespace std
{
	class string{
	public:

		class iterator{
		public:
			iterator(const iterator&);
		    iterator();
		};

		class const_iterator{
		public:
			char* i_str;

		    const_iterator(const const_iterator&);
		    const_iterator();
		    const_iterator& operator=(const const_iterator&);

		    const_iterator(char* s)
		    {
		    	i_str = s;
		    }

		    template<typename T>
		    const T* operator -> ();

		    template<class T>
		    const T& operator * ();
		    const_iterator& operator * ();

		    const_iterator& operator ++ ();
		    const_iterator& operator ++ (int);

		    const_iterator& operator -- ();
		    const_iterator& operator -- (int);

		    bool operator == ( const const_iterator&)const;
		    bool operator != ( const const_iterator&)const;

		    bool operator < ( const const_iterator&)const;
		    bool operator > ( const const_iterator&)const;

		    bool operator <= ( const const_iterator&)const;
		    bool operator >= ( const const_iterator&)const;

		    const_iterator operator + (int) const;
		    const_iterator operator - (int) const;

		    const_iterator& operator += (int);
		    const_iterator& operator -= (int);
		};

		string ();
		string (char*);
		string (const char * s, size_t n);
		string ( const string& str, size_t pos, size_t n );
		string (string& s, size_t n);
		string (char c, size_t n);
		string (int len);
		string (const_iterator begin, const_iterator end);
		char* c_str ( ) const;
		bool operator== (string& b);
		bool operator== ( const char* lhs);
		bool operator== (string& a, string& b);
		bool operator== ( const char* lhs, string& rhs );
		bool operator== ( string& lhs, const char* rhs );
		bool operator!= (string& a);
		bool operator!= ( const char* lhs );
		bool operator!= ( const char* lhs, string& rhs );
		bool operator!= ( string& lhs, const char* rhs );
		bool operator> (string& a);
		bool operator> (const char* a);
		bool operator> ( const char* lhs, string& rhs );
		bool operator> ( string& lhs, const char* rhs );
		bool operator< (string& a);
		bool operator< (const char* a);
		bool operator< ( const char* lhs, string& rhs );
		bool operator< ( string& lhs, const char* rhs );
		bool operator>= (string& a);
		bool operator>= ( const char* lhs );
		bool operator<= (string& a);
		bool operator<= ( const char* lhs );
		string& operator= ( string& str );
		string& operator= ( const string& str );
		string& operator= ( const char* s );
		string& operator= ( char* s );
		string& operator= ( char c );
		string& operator+= ( string& s);
		string& operator += (const char* s);
		string& operator+= (char s);
		char& operator[] ( size_t pos );
		char at ( size_t pos ) const;
		bool empty ( ) const;
		size_t length() const;
		int compare ( const string& s ) const;
		int compare ( const char* s ) const;
		int compare ( int pos1, size_t n1, string& s ) const;
		int compare ( int pos1, size_t n1, const char* s ) const;
		int compare ( size_t pos1, size_t n1, string& s, size_t pos2, size_t n2 ) const;
		string& substr ( size_t pos, size_t n )
		{
			__ESBMC_HIDE:
			__ESBMC_assert((pos < this->length()) && ((pos+n) <= this->length()), "overflow");
			int i,k;
			int lenOne = n+1;
			char* one = new char[lenOne];
			for(k=0,i=pos;i<(pos+n);k++,i++){
				one[k] = this->str[i];
			}
			one[k]='\0';
			string tmp(one);
			return tmp;
		}
		string& substr ( size_t pos ) const
		{
			__ESBMC_HIDE:
			__ESBMC_assert(pos < this->length(), "overflow");
			int i,k;
			int len = this->length();
			int lenOne = len+1;
			char* one = new char[lenOne];
			for(k=0,i=pos;i<len;k++,i++){
				one[k] = this->str[i];
			}
			one[k]='\0';
			string tmp(one);
			return tmp;
		}
		size_t find_first_of ( const string& s, size_t pos = 0 ) const;
		size_t find_first_of ( const char* s, size_t pos = 0 ) const;
		size_t find_first_of ( char c, size_t pos = 0 ) const;
		size_t find ( string& s, size_t pos = 0 ) const;
		size_t find ( const char* s, size_t pos = 0 ) const;
		size_t find ( const char* s, size_t pos = 0 , size_t n) const;
		size_t find ( char c, size_t pos = 0 ) const;
		string& assign ( string& s );
		string& assign ( const char* s, size_t n );
		string& assign ( string& s, size_t pos = 0, size_t n );
		string& assign ( const char* s );
		string& assign ( size_t n, char c );
		string& assign ( const_iterator one, const_iterator two );
		string& append ( string& s );
		string& append ( const char* s, size_t n );
		string& append ( string& s, size_t pos, size_t n );
		string& append ( const char* s );
		string& append ( size_t n, char c );
		string& append ( const_iterator one, const_iterator two );
		void swap ( string& s );
		void resize ( size_t n, char c );
		void resize ( size_t n );
		size_t capacity ( ) const;
		size_t max_size ( ) const;
		int size() const;
		size_t rfind ( string& s, size_t pos = npos ) const;
		size_t rfind ( const char* s, size_t pos = npos ) const;
		size_t rfind ( char c, size_t pos = npos ) const;
		size_t rfind ( const char* s, size_t pos = 0 , size_t n) const;
		size_t find_last_of ( const string& s, size_t pos = npos ) const;
		size_t find_last_of ( const char* s, size_t pos = npos ) const;
		size_t find_last_of ( char c, size_t pos = npos ) const;
		size_t find_first_not_of ( const string& s, size_t pos = 0 ) const;
		size_t find_first_not_of ( const char* s, size_t pos = 0 ) const;
		size_t find_first_not_of ( char c, size_t pos = 0 ) const;
		string& erase ( size_t pos = 0 );
		string& erase ( size_t pos = 0, size_t n );
		string& erase ( size_t pos = 0, size_t n , char* tmp );
		string& erase ( size_t pos = 0);
		string& replace ( size_t pos1, size_t n1,   const string& s );
		string& replace ( size_t pos1, size_t n1, string& s, size_t pos2, size_t n2 );
		string& replace ( size_t pos1, size_t n1, char* s, size_t pos2, size_t n2 );
		string& replace ( size_t pos1, size_t n1,   const char* s, size_t n2 );
		string& replace ( size_t pos1, size_t n1,   const char* s );
		string& replace ( size_t pos1, size_t n1,   size_t n2, char c );
		string& insert ( size_t pos1, string& s );
		string& insert ( size_t pos1, string& s, size_t pos2, size_t n );
		string& insert ( size_t pos1, const char* s, size_t n);
		string& insert ( size_t pos1, const char* s );
		string& insert ( size_t pos1, size_t n, char c );
		iterator insert ( const_iterator p, char c );
		void insert ( const_iterator p, size_t n, char c );
		template<class InputIterator>
		    void insert ( iterator p, InputIterator first, InputIterator last );
		size_t copy ( char* s, size_t n, size_t pos = 0) const;
		const char* data() const;

	    const_iterator begin() const{
	    	const_iterator first(this->str);
	    	return first;
	    }

	    const_iterator end() const{
	    	const_iterator end(this->str);
	    	return end;
	    }

		string& operator+ ( string& s)
		{
			int rhsLen = s._size;
			int lhsLen = this->_size;
		    int totalLen = lhsLen + rhsLen;
		    char temp[totalLen+1];
		    int i, j, k;
		    for (i=0; i<lhsLen; i++)
		        temp[i] = this->str[i];
		    temp[i]='\0';
		    for(j=i, k=0; j<totalLen; j++, k++)
		    	temp[j] = s.str[k];
		    temp[j]='\0';
		    string next(totalLen);
		    strcpy(next.str, temp);
		    return next;
		}

		string& operator+ ( const char* s)
		{
			__ESBMC_HIDE:
		    int rhsLen = strlen(s);
		    int totalLen = this->_size + rhsLen;
		    char temp[totalLen+1];
			int i, j, k;
			for (i=0; i<this->_size; i++)
				temp[i] = this->str[i];
			temp[i]='\0';
			for(j=i, k=0; j<totalLen; j++, k++)
			  	temp[j] = s[k];
			temp[j]='\0';
			string next(totalLen);
			strcpy(next.str, temp);
			return next;
		}

		string& operator+ ( char s)
		{
			__ESBMC_HIDE:
		    int totalLen = this->_size +1;
		    char temp[totalLen+1];
		    int i=0, j, k;
		    if(this->_size!=0)
		    	for (i=0; i<this->_size; i++)
		    		temp[i] = this->str[i];
		    temp[i] = s;
		    temp[i++] = '\0';
		    string next(totalLen);
		    strcpy(next.str, temp);
		    return next;
		}

		template <class T>
		string& assign ( T first, T last ){
			int i;
			this->_size = first;
			this->str = new char[first];
			for (i = 1;i<first;i++){
				this->str[i] = last;
			}
			return *this;
		}

		template <class InputIterator>
		string& append ( InputIterator first, InputIterator last )
		{
		    int rhsLen = first;
		    int totalLen = this->_size + rhsLen;
		    string temp(totalLen);
		    int i, j, k;
		    for (i=0; i<this->_size; i++)
		        temp[i] = this->str[i];
		    for(j=i, k=0; j<temp._size; j++, k++)
		    	temp.str[j] = last;
		    *this = temp;
		    return *this;
		}

	private:
		char *str;
		int _size;
	};
}

namespace std
{
	string::string ()
	{
		str=new char[1];
		str="";
		_size = 0;
	}

	string::string (char *s)
	{
		__ESBMC_HIDE:
		_size=strlen(s);
		str=new char[_size+1];
		//npos = _size-1;
		strcpy(str,s);
	}

	string::string (const char * s, size_t n)
	{
		__ESBMC_HIDE:
		//__ESBMC_assert(n < strlen(s),"string overflow");
		int i;
		str=new char[n+1];
		_size = n;
		for(i=0;(i<_size)&&(s[i]!='\0');i++)
			str[i]=s[i];
		str[i]='\0';
	}

	string::string (string& s, size_t n)
	{
		__ESBMC_HIDE:
		int i;
		str=new char[n+1];
		_size = n;
		if(n>s.length())
			n=s.length();
		for(i=0;i<_size;i++)
			str[i]=s.str[i];
		str[i]='\0';
	}

	string::string(int len)
	{
	    str = new char [len+1];
	    _size = len;
	}

	string::string(char c, size_t n)
	{
	    str = new char [n+1];
	    for(int i = 0; i <= n; i++)
	        str[i] = c;
	    _size = n;
	}

	char* string::c_str () const
	{
		__ESBMC_HIDE:
		return str;
	}

	inline string::ostream& operator << (ostream& o, string)
	{
		return o;
	}

	inline string::ostream& operator << (ostream& o, struct const_iterator&)
	{
		return o;
	}

	inline string::istream& operator >> (istream& is, string)
	{
		return is;
	}

	bool string::operator== (string& b)
	{
		__ESBMC_HIDE:
               if (strcmp(this->str, b.str) == 0)
                    return true;
               else
                    return false;
	}

	bool string::operator== ( const char* lhs)
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp((char*)lhs, this->str);
		if (aux == 0){
			return true;
		}else{
			return false;
		}
	}

	bool string::operator== (string& a, string& b)
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp(b.c_str(), a.c_str());
		if (aux == 0){
			return true;
		}else{
			return false;
		}
	}

	bool string::operator== ( const char* lhs, string& rhs )
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp((char*)lhs, rhs.c_str());
		if (aux == 0){
			return true;
		}else{
			return false;
		}
	}

	bool string::operator== ( string& lhs, const char* rhs )
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp(lhs.c_str(), (char*)rhs);
		if (aux == 0){
			return true;
		}else{
			return false;
		}
	}

	bool string::operator!= (string& a)
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp(a.c_str(), this->c_str());
		if (aux == 0){
			return false;
		}else{
			return true;
		}
	}

	bool string::operator!= ( const char* lhs )
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp((char*)lhs, this->c_str());
		if (aux == 0){
			return false;
		}else{
			return true;
		}
	}

	bool string::operator!= ( const char* lhs, string& rhs )
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp((char*)lhs, rhs.c_str());
		if (aux == 0){
			return false;
		}else{
			return true;
		}
	}

	bool string::operator!= ( string& lhs, const char* rhs )
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp(lhs.c_str(), (char*)rhs);
		if (aux == 0){
			return false;
		}else{
			return true;
		}
	}

	bool string::operator> (string& a)
	{
		__ESBMC_HIDE:
		if ( this->length() > a.length() )
			return true;
		return false;
	}

	bool string::operator> (const char* a)
	{
		__ESBMC_HIDE:
		if ( this->length() > strlen(a) )
			return true;
		return false;
	}

	bool string::operator> ( const char* lhs, string& rhs )
	{
		__ESBMC_HIDE:
		if ( strlen(lhs) > rhs.length() )
			return true;
		return false;
	}

	bool string::operator> ( string& lhs, const char* rhs )
	{
		__ESBMC_HIDE:
		if ( lhs.length() > strlen(rhs) )
			return true;
		return false;
	}

	bool string::operator< (string& a)
	{
		__ESBMC_HIDE:
		if ( this->length() < a.length() ){
			return true;
		}else{
			return false;
		}
	}

	bool string::operator< (const char* a)
	{
		__ESBMC_HIDE:
		if ( this->length() < strlen(a) )
			return true;
		return false;
	}

	bool string::operator< ( const char* lhs, string& rhs )
	{
		__ESBMC_HIDE:
		if ( strlen(lhs) < rhs.length() )
			return true;
		return false;
	}

	bool string::operator< ( string& lhs, const char* rhs )
	{
		__ESBMC_HIDE:
		if ( lhs.length() < strlen(rhs) )
			return true;
		return false;
	}

	bool string::operator >=(string& a)
	{
		__ESBMC_HIDE:
		if ( this->length() >= a.length() )
			return true;
		return false;
	}

	bool string::operator>= ( const char* lhs )
	{
		__ESBMC_HIDE:
		if ( this->length() >= (strlen(lhs)) )
			return true;
		return false;
	}

	bool string::operator <=(string& a)
	{
		__ESBMC_HIDE:
		if ( this->length() <= a.length() )
			return true;
		return false;
	}

	bool string::operator <=(const char* lhs)
	{
		__ESBMC_HIDE:
		if ( this->length() <= strlen(lhs) )
			return true;
		return false;
	}

	size_t  string::length() const
	{
		return this->_size;
	}

	char& string::operator[](size_t pos)
	{
		__ESBMC_assert( (pos>=0) && (pos<this->_size) , "Error! Invalid access memory area");
	    if (pos > this->_size)
	        return this->str[this->_size-1];
	    else
	        return this->str[pos];
	}

	char string::at ( size_t pos ) const
	{
		__ESBMC_assert( (pos>=0) && (pos<this->_size) , "Error! Invalid access memory area");
		int i;
		if (pos>this->length()) {
			throw("out_of_range");
		}
		else {
			return this->str[pos];
		}
	}

	bool string::empty ( ) const
	{
		if (this->_size == 0)
			return true;
		return false;
	}

	string& string::operator= ( string& str )
	{
		__ESBMC_HIDE:
		int i, len;
		this->_size=str.length();
		this->str=new char[this->_size+1];
		len = str.length();
		for(i=0;i<len;i++){
			this->str[i] = str.str[i];
		}
		this->str[i] = '\0';
		return *this;
	}

	string& string::operator= ( const char* s )
	{
		this->_size=strlen(s);
		this->str=new char[this->_size+1];
		return string(strcpy(this->c_str(), s));
	}

	string& string::operator= ( char* s )
	{
		this->_size=strlen(s);
		this->str=new char[this->_size+1];
		return string(strcpy(this->c_str(), s));
	}

	string& string::operator= ( char s )
	{
		this->_size=1;
		this->str=new char[this->_size+1];
		this->str[0] = s;
		this->str[1] = '\0';
		return *this;
	}

	string& string::operator+=( string& s)
	{
		int rhsLen = s._size;
		int lhsLen = this->_size;
	    int totalLen = lhsLen + rhsLen;
	    char temp[totalLen+1];
	    int i, j, k;
	    for (i=0; i<lhsLen; i++)
	        temp[i] = this->str[i];
	    temp[i]='\0';
	    for(j=i, k=0; j<totalLen; j++, k++)
	    	temp[j] = s.str[k];
	    temp[j]='\0';
	    this->str = new char[totalLen];
	    this->_size = totalLen;
	    strcpy(this->str, temp);
	    return *this;
	}

	string& string::operator+= (const char* s)
	{
		int rhsLen = strlen(s);
		int lhsLen = this->_size;
	    int totalLen = lhsLen + rhsLen;
	    char temp[totalLen+1];
	    int i, j, k;
	    for (i=0; i<lhsLen; i++)
	        temp[i] = this->str[i];
	    temp[i]='\0';
	    for(j=i, k=0; j<totalLen; j++, k++)
	    	temp[j] = s[k];
	    temp[j]='\0';
	    this->str = new char[totalLen];
	    this->_size = totalLen;
	    strcpy(this->str, temp);
	    return *this;
	}

	string& string::operator+= (char s)
	{
	    int totalLen = this->_size +1;
	    char temp[totalLen+1];
	    int i=0;
	    if(this->_size!=0){
	    	for (i=0; i<this->_size; i++){
	    		temp[i] = this->str[i];
	    	}
	    }
	    temp[i] = s;
	    i++;
	    temp[i] = '\0';
	    this->str = new char[totalLen];
	    this->_size = totalLen;
	    strcpy(this->str, temp);
		return *this;
	}

	void string::swap ( string& s )
	{
		string aux(s.str);
		s.str = this->str;
		s._size = this->_size;
		this->str = aux.str;
		this->_size = aux._size;
	}

	size_t string::capacity ( ) const
	{
		return this->_size;
	}

	size_t string::max_size ( ) const
	{
		int nondet;
		return nondet;
	}

	int string::size() const
	{
		return this->_size;
	}

	void string::resize ( size_t n )
	{
		int num = this->_size,i;
		char *tmp = new char[n+1];
		for(i=0;i<n;i++){
			tmp[i] = this->str[i];
		}
		tmp[i]='\0';
		this->_size= n;
		this->str=new char[n+1];
		for(i=0;i<n;i++)
			this->str[i] = tmp[i];
		this->str[i]='\0';
	}

	void string::resize ( size_t n, char c )
	{
		int num, i;
		num = this->length();
		string tmp(this->str);
		this->_size= n;
		this->str=new char[n];
		for(i=0;i<num;i++)
			this->str[i] = tmp.str[i];
		for(i=num;i<(this->_size);i++)
			this->str[i] = c;
		this->str[i]='\0';
	}

	string& string::assign ( string& s )
	{
		*this=s;
		return *this;
	}

	string& string::assign ( string& s, size_t pos = 0, size_t n )
	{
		this->_size=(n);
		this->str=new char[this->_size+1];
		strncpy(this->str, s.str+pos, n);
		return *this;
	}

	string& string::assign ( const char* s, size_t n )
	{
		this->_size=(n);
		this->str=new char[this->_size];
		strncpy(this->str, s, n);
		return *this;
	}

	string& string::assign ( const char* s )
	{
		*this=s;
		return *this;
	}

	string& string::assign ( size_t n, char c )
	{
		int i;
		this->_size = n;
		this->str = new char[n];
		for (i = 1;i<n;i++){
			this->str[i] = c;
		}
		return *this;
	}

	size_t string::copy ( char* s, size_t n, size_t pos = 0) const
	{
		size_t aux = n + pos;
		if (pos>this->size()){
			throw("out_of_range");
		}
		strncpy(s, this->c_str()+pos, aux);
		return n;
	}

	const char* string::data() const
	{
		return this->str;
	}

	string& string::append (  string& s )
	{
		*this += s;
		return *this;
	}

	string& string::append ( const char* s, size_t n )
	{
		if( n > strlen(s) )
			throw("out_of_range");
	    int rhsLen = n;
	    int totalLen = this->_size + rhsLen;
	    string temp(totalLen);
	    int i, j, k;
	    for (i=0; i<this->_size; i++)
	        temp[i] = this->str[i];
	    for(j=i, k=0; j<temp._size; j++, k++)
	    	temp.str[j] = s[k];
	    *this = temp;
	    return *this;
	}

	string& string::append ( string& s, size_t pos, size_t n )
	{
		if( (pos > s._size) || (n > (s._size-pos)) )
			throw("out_of_range");

	    int rhsLen = n;
	    int totalLen = this->_size + rhsLen;
	    string temp(totalLen);
	    int i, j, k;
	    for (i=0; i<this->_size; i++)
	        temp[i] = this->str[i];
	    for(j=i, k=pos; j<temp._size; j++, k++)
	    	temp.str[j] = s.str[k];
	    *this = temp;
	    return *this;
	}

	string& string::append ( const char* s )
	{
	    int rhsLen = strlen(s);
	    int totalLen = this->_size + rhsLen;
	    string temp(totalLen);
	    int i, j, k;
	    for (i=0; i<this->_size; i++)
	        temp[i] = this->str[i];
	    for(j=i, k=0; j<temp._size; j++, k++)
	    	temp.str[j] = s[k];
	    *this = temp;
	    return *this;
	}

	string& string::append ( size_t n, char c )
	{
	    int rhsLen = n;
	    int totalLen = this->_size + rhsLen;
	    string temp(totalLen);
	    int i, j, k;
	    for (i=0; i<this->_size; i++)
	        temp[i] = this->str[i];
	    for(j=i, k=0; j<temp._size; j++, k++)
	    	temp.str[j] = c;
	    *this = temp;
	    return *this;
	}

	size_t string::find ( char c, size_t pos = 0 ) const
	{
		int i;
		int len = this->length();
		for(i=0;i<len;i++)
			if(this->str[i] == c)
				return i;

	}

	size_t string::find ( string& s, size_t pos = 0 ) const
	{
		int len = this->length();
		int lim = pos;
		char* s1 = new char[len+1];
		strcpy(s1,this->str);
		int slen = s.length();
		char* s2 = new char[slen+1];
		strcpy(s2,s.str);
		pos =-1;
		size_t i, j;

		for (i = lim; i < len; i++) {
			for (j = 0; (j < slen) && ((i+j) < len); j++) {
				if (s1[i+j] != s2[j]) {
					break;
				}else{
					if(pos == -1){
						pos = i+j;
					}
				}
			}
			if (s2[j] == '\0') {
				return pos;
			}
		}

		return -1;
	}

	size_t string::find ( const char* s, size_t pos = 0 , size_t n) const
	{
		size_t i, j;

		int len = this->length();
		int lim = pos;
		char* s1 = new char[len+1];
		strcpy(s1,this->str);

		int slen = n;
		char* s2 = new char[slen+1];
		for(i=0;i<slen;i++){
			s2[i] = s[i];
		}
		s2[i] = '\0';

		pos =-1;

		for (i = lim; i < len; i++) {
			for (j = 0; (j < slen) && ((i+j) < len); j++) {
				if (s1[i+j] != s2[j]) {
					break;
				}else{
					if(pos == -1){
						pos = i+j;
					}
				}
			}
			if (s2[j] == '\0') {
				return pos;
			}
		}

		return -1;
	}

	size_t string::find ( const char* s, size_t pos = 0 ) const
	{
		int len = this->length();
		int lim = pos;
		char* s1 = new char[len+1];
		strcpy(s1,this->str);
		int slen = strlen(s);
		char* s2 = new char[slen+1];
		strcpy(s2,s);
		pos =-1;
		size_t i, j;

		for (i = lim; i < len; i++) {
			for (j = 0; (j < slen) && ((i+j) < len); j++) {
				if (s1[i+j] != s2[j]) {
					break;
				}else{
					if(pos == -1){
						pos = i+j;
					}
				}
			}
			if (s2[j] == '\0') {
				return pos;
			}
		}

		return -1;
	}

	size_t string::rfind ( char c, size_t pos = 0 ) const
	{
		int i;
		int len = this->length();
		for(i=len;i>0;i--)
			if(this->str[i] == c)
				return i;

	}

	size_t string::rfind ( string& s, size_t pos = 0 ) const
	{
		int len = this->length();
		int lim = pos;
		char* s1 = new char[len+1];
		strcpy(s1,this->str);
		int slen = s.length();
		char* s2 = new char[slen+1];
		strcpy(s2,s.str);
		pos =-1;
		size_t i, j;

		for (i = len; i > lim; i--) {
			for (j = 0; (j < slen) && ((i+j) < len); j++) {
				if (s1[i+j] != s2[j]) {
					break;
				}else{
					if(pos == -1){
						pos = i-j;
					}
				}
			}
			if ((s2[j] == '\0')) {
				return pos;
			}
		}

		return -1;
	}

	size_t string::rfind ( const char* s, size_t pos = 0 , size_t n) const
	{
		size_t i, j;

		int len = this->length();
		int lim = pos;
		char* s1 = new char[len+1];
		strcpy(s1,this->str);

		int slen = n;
		char* s2 = new char[slen+1];
		for(i=0;i<slen;i++){
			s2[i] = s[i];
		}
		s2[i] = '\0';

		pos =-1;

		for (i = lim; i < len; i++) {
			for (j = 0; (j < slen) && ((i+j) < len); j++) {
				if (s1[i+j] != s2[j]) {
					break;
				}else{
					if(pos == -1){
						pos = i+j;
					}
				}
			}
			if (s2[j] == '\0') {
				return pos;
			}
		}

		return -1;
	}

	size_t string::rfind ( const char* s, size_t pos = 0 ) const
	{
		int len = this->length();
		int lim = pos;
		char* s1 = new char[len+1];
		strcpy(s1,this->str);
		int slen = strlen(s);
		char* s2 = new char[slen+1];
		strcpy(s2,s);
		pos =-1;
		size_t i, j;

		for (i = lim; i < len; i++) {
			for (j = 0; (j < slen) && ((i+j) < len); j++) {
				if (s1[i+j] != s2[j]) {
					break;
				}else{
					if(pos == -1){
						pos = i+j;
					}
				}
			}
			if (s2[j] == '\0') {
				return pos;
			}
		}

		return -1;
	}

	string& string::insert ( size_t pos1, string& s )
	{
		__ESBMC_HIDE:
		int len  = this->length(),i,k;
		__ESBMC_assert(pos1 < len, "overflow");
		int lenOne = pos1 +1;
		char* one = new char[lenOne];
		for(i=0;i<pos1;i++){
			one[i] = this->str[i];
		}
		int lenTwo = (len-pos1)+1;
		char* two = new char[lenTwo];
		for(k=0,i=pos1;i<len;i++,k++){
			two[k] = this->str[i];
		}
		int totalLen = s.length() + len;
		this->str = new char[totalLen];
		this->_size = totalLen;

		for(i=0;i<lenOne-1;i++){
			this->str[i] = one[i];
		}
		for(k=0;k<s.length();k++,i++){
			this->str[i] = s.str[k];
		}
		for(k=0;k<lenTwo-1;k++,i++){
			this->str[i] = two[k];
		}
		this->str[i] = '\0';
		return *this;
	}

	string& string::insert ( size_t pos1, string& s, size_t pos2, size_t n )
	{
		__ESBMC_HIDE:
		int len  = this->length(),i,k;
		int lim = n + pos2;
		int sLen = s.length();
		__ESBMC_assert(pos1 < len, "overflow");
		__ESBMC_assert(lim < sLen, "overflow");
		int lenOne = pos1 +1;
		char* one = new char[lenOne];
		for(i=0;i<pos1;i++){
			one[i] = this->str[i];
		}
		int lenTwo = (len-pos1)+1;
		char* two = new char[lenTwo];
		for(k=0,i=pos1;i<len;i++,k++){
			two[k] = this->str[i];
		}
		int totalLen = n + len;
		this->str = new char[totalLen+1];
		this->_size = totalLen;

		for(i=0;i<lenOne-1;i++){
			this->str[i] = one[i];
		}
		for(k=pos2;k<lim;k++,i++){
			this->str[i] = s.str[k];
		}
		for(k=0;k<lenTwo-1;k++,i++){
			this->str[i] = two[k];
		}
		this->str[i] = '\0';
		return *this;
	}

	string& string::insert ( size_t pos1, const char* s, size_t n)
	{
		__ESBMC_HIDE:
		int len  = this->length(),i,k;
		int lim = n;
		int sLen = strlen(s);
		__ESBMC_assert(pos1 < len, "overflow");
		__ESBMC_assert(lim < sLen, "overflow");
		int lenOne = pos1 +1;
		char* one = new char[lenOne];
		for(i=0;i<pos1;i++){
			one[i] = this->str[i];
		}
		int lenTwo = (len-pos1)+1;
		char* two = new char[lenTwo];
		for(k=0,i=pos1;i<len;i++,k++){
			two[k] = this->str[i];
		}
		int totalLen = n + len;
		this->str = new char[totalLen+1];
		this->_size = totalLen;

		for(i=0;i<lenOne-1;i++){
			this->str[i] = one[i];
		}
		for(k=0;k<lim;k++,i++){
			this->str[i] = s[k];
		}
		for(k=0;k<lenTwo-1;k++,i++){
			this->str[i] = two[k];
		}
		this->str[i] = '\0';
		return *this;
	}

	string& string::insert ( size_t pos1, const char* s )
	{
		__ESBMC_HIDE:
		int len  = this->length(),i,k;
		int sLen = strlen(s);
		//__ESBMC_assert(pos1 < len, "overflow");
		int lenOne = pos1 +1;
		char* one = new char[lenOne];
		for(i=0;i<pos1;i++){
			one[i] = this->str[i];
		}
		int lenTwo = (len-pos1)+1;
		char* two = new char[lenTwo];
		for(k=0,i=pos1;i<len;i++,k++){
			two[k] = this->str[i];
		}
		int totalLen = len + strlen(s);
		this->str = new char[totalLen+1];
		this->_size = totalLen;

		for(i=0;i<lenOne-1;i++){
			this->str[i] = one[i];
		}
		for(k=0;k<sLen;k++,i++){
			this->str[i] = s[k];
		}
		for(k=0;k<lenTwo-1;k++,i++){
			this->str[i] = two[k];
		}
		this->str[i] = '\0';
		return *this;
	}

	string& string::insert ( size_t pos1, size_t n, char c )
	{
		int i;
		char *s = new char[n+1];
		for (i = 0;i<n;i++){
			s[i] = c;
		}
		int len  = this->length(),i,k;
		int sLen = n;
		__ESBMC_assert(pos1 < len, "overflow");
		int lenOne = pos1 +1;
		char* one = new char[lenOne];
		for(i=0;i<pos1;i++){
			one[i] = this->str[i];
		}
		int lenTwo = (len-pos1)+1;
		char* two = new char[lenTwo];
		for(k=0,i=pos1;i<len;i++,k++){
			two[k] = this->str[i];
		}
		int totalLen = len + n;
		this->str = new char[totalLen+1];
		this->_size = totalLen;

		for(i=0;i<lenOne-1;i++){
			this->str[i] = one[i];
		}
		for(k=0;k<sLen;k++,i++){
			this->str[i] = s[k];
		}
		for(k=0;k<lenTwo-1;k++,i++){
			this->str[i] = two[k];
		}
		this->str[i] = '\0';
		return *this;
	}

	string& string::erase ( size_t pos = 0, size_t n )
	{
		__ESBMC_HIDE:
		__ESBMC_assert((pos < this->length()) && ((pos+n) <= this->length()), "overflow");
		int i,k,len  = this->length();
		int lenOne = pos +1;
		char* one = new char[lenOne];
		for(i=0;i<pos;i++){
			one[i] = this->str[i];
		}
		int lenTwo = (len-(pos+n))+1;
		char* two = new char[lenTwo];
		for(k=0,i=pos+n;i<len;i++,k++){
			two[k] = this->str[i];
		}
		int totalLen =len-n;
		this->str = new char[totalLen+1];
		this->_size = totalLen;
		for(i=0;i<lenOne-1;i++){
			this->str[i] = one[i];
		}
		for(k=0;k<lenTwo-1;k++,i++){
			this->str[i] = two[k];
		}
		this->str[i] = '\0';
		return *this;
	}

    string& string::erase ( size_t pos = 0)
    {
        __ESBMC_HIDE:
    int n = this->length()-1;
        __ESBMC_assert((pos < this->length()) && ((pos+n) <= this->length()), "overflow");
        int i,k,len  = this->length();
        int lenOne = pos +1;
        char* one = new char[lenOne];
        for(i=0;i<pos;i++){
            one[i] = this->str[i];
        }
        int lenTwo = (len-(pos+n))+1;
        char* two = new char[lenTwo];
        for(k=0,i=pos+n;i<len;i++,k++){
            two[k] = this->str[i];
        }
        int totalLen =len-n;
        this->str = new char[totalLen+1];
        this->_size = totalLen;
        for(i=0;i<lenOne-1;i++){
            this->str[i] = one[i];
        }
        for(k=0;k<lenTwo-1;k++,i++){
            this->str[i] = two[k];
        }
        this->str[i] = '\0';
        return *this;
    }

	string& string::replace ( size_t pos1, size_t n1, const string& s )
	{
		__ESBMC_HIDE:
		this->erase(pos1,n1);
		this->insert(pos1,s.str);
		return *this;
	}

	string& string::replace ( size_t pos1, size_t n1, string& s, size_t pos2, size_t n2 )
	{
		this->erase(pos1,n1);
		int i,k;
		char *tmp = new char[n2+1];
		for(k=0,i=pos2;i<(n2+pos2);i++,k++)
			tmp[k]=s.str[i];
		tmp[k] = '\0';
		this->insert(pos1,tmp);
		return *this;
	}

	string& string::replace ( size_t pos1, size_t n1, const char* s, size_t n2 )
	{
		this->erase(pos1,n1);
		int i,k;
		char *tmp = new char[n2+1];
		for(k=0,i=0;i<n2;i++,k++)
			tmp[k]=s[i];
		tmp[k] = '\0';
		this->insert(pos1,tmp);
		return *this;
	}

	string& string::replace ( size_t pos1, size_t n1, const char* s )
	{
		this->erase(pos1,n1);
		int i,k,n2;
		n2 = strlen(s);
		char *tmp = new char[n2+1];
		for(k=0,i=0;i<n2;i++,k++)
			tmp[k]=s[i];
		tmp[k] = '\0';
		this->insert(pos1,tmp);
		return *this;
	}

	string& string::replace ( size_t pos1, size_t n1, size_t n2, char c )
	{
		this->erase(pos1,n1);
		int k;
		char *tmp = new char[n2+1];
		for(k=0;k<n2;k++)
			tmp[k]=c;
		tmp[k] = '\0';
		this->insert(pos1,tmp);
		return *this;
	}

	int string::compare ( const char* s ) const
	{
		__ESBMC_HIDE:
		int i;
		int sLen = strlen(s);
		int len = this->length();
		if( len < sLen)
			return -1;
		if (len > sLen)
			return 1;
		for(i=0;i<sLen;i++){
			if(this->str[i]!=s[i]){
				return 2;
			}
		}
		return 0;
	}

	int string::compare ( const string& s ) const
	{
		__ESBMC_HIDE:
		int i;
		int sLen = s.length();
		int len = this->length();
		if( len < sLen)
			return -1;
		if (len > sLen)
			return 1;
		for(i=0;i<sLen;i++){
			if(this->str[i]!=s.str[i]){
				return 2;
			}
		}
		return 0;
	}

	int string::compare ( int pos1, size_t n1, const char* s ) const
	{
		__ESBMC_HIDE:
		int i,k;
		char* tmp = new char[n1+1];
		for(k=0,i=pos1;i<(pos1+n1);i++,k++){
			tmp[k] = this->str[i];
		}
		tmp[k] = '\0';
		int sLen = strlen(s);
		int len = strlen(tmp);
		if( len < sLen)
			return -1;
		if (len > sLen)
			return 1;
		for(i=0;i<sLen;i++){
			if(tmp[i]!=s[i]){
				return 2;
			}
		}
		return 0;
	}

	int string::compare ( int pos1, size_t n1, string& s ) const
	{
		__ESBMC_HIDE:
		int i,k;
		char* tmp = new char[n1+1];
		for(k=0,i=pos1;i<(pos1+n1);i++,k++){
			tmp[k] = this->str[i];
		}
		tmp[k] = '\0';
		int sLen = s.length();
		int len = strlen(tmp);
		if( len < sLen)
			return -1;
		if (len > sLen)
			return 1;
		for(i=0;i<sLen;i++){
			if(tmp[i]!=s.str[i]){
				return 2;
			}
		}
		return 0;
	}

	int string::compare ( size_t pos1, size_t n1, string& s, size_t pos2, size_t n2 ) const
	{
		__ESBMC_HIDE:
		int i,k;

		char* tmp = new char[n1+1];
		for(k=0,i=pos1;i<(pos1+n1);i++,k++){
			tmp[k] = this->str[i];
		}
		tmp[k] = '\0';

		char* tmp2 = new char[n2+1];
		for(k=0,i=pos2;i<(pos2+n2);i++,k++){
			tmp2[k] = s.str[i];
		}
		tmp2[k] = '\0';

		int sLen = strlen(tmp2);
		int len = strlen(tmp);

		if( len < sLen)
			return -1;
		if (len > sLen)
			return 1;

		for(i=0;i<sLen;i++){
			if(tmp[i]!=tmp2[i]){
				return 2;
			}
		}

		return 0;
	}
#if 0






	string& string::replace ( size_t pos1, size_t n1, char* s, size_t pos2, size_t n2 );


	size_t string::find ( const char* s, size_t pos = 0 , size_t n) const
	{
		__ESBMC_assert((strlen(s)<=this->_size)&&(pos<this->_size)&&(n-pos<this->_size), "string overflow");
		return strspn(str+pos,s);
	}






	size_t string::find_first_of ( const string& s, size_t pos = 0 ) const
	{
		return strcspn(s.c_str(), str+pos);
	}
	size_t string::find_first_of ( const char* s, size_t pos = 0 ) const
	{
		return strcspn(s, str+pos);
	}
	size_t string::find_first_of ( char c, size_t pos = 0 ) const
	{
		__ESBMC_HIDE:
		char *aux;
		aux = strchr(str+pos, c);
		if(aux!=0)
			return 1;
		return 0;
	}



	size_t string::find_last_of ( const string& s, size_t pos = npos ) const
	{
		return strspn_reverse(s.c_str(), str+pos);
	}
	size_t string::find_last_of ( const char* s, size_t pos = npos ) const
	{
		return strspn_reverse(str, s+pos);
	}
	size_t string::find_last_of ( char c, size_t pos = npos ) const
	{
		return strspn_reverse((const char *)c, str+pos);
	}
	size_t string::find_first_not_of ( const string& s, size_t pos = 0 ) const
	{
		__ESBMC_assert(pos>this->length(), "overflow");
		int i=0,j=0;
		const char* tmp = this->c_str();
		const char* tmp2 = s.c_str();
		while(tmp2[i]!='\0')
		{
			while(tmp[j]!='\0')
			{
				if (tmp[j] != tmp2[i])
					return j;
				j++;
			}
			i++;
		}
		j--;
		return j;
	}
	size_t string::find_first_not_of ( const char* s, size_t pos = 0 ) const
	{
		__ESBMC_assert(pos>this->length(), "overflow");
		int i=0,j=0;
		const char* tmp = this->c_str();
		while(s[i]!='\0')
		{
			while(tmp[j]!='\0')
			{
				if (tmp[j] != s[i])
					return j;
				j++;
			}
			i++;
		}
		j--;
		return j;
	}
	size_t string::find_first_not_of ( char c, size_t pos = 0 ) const
	{
		__ESBMC_assert(pos>this->length(), "overflow");
		int j=0;
		const char* tmp = this->c_str();
		while(tmp[j]!='\0')
		{
			if (tmp[j] != c)
				return j;
			j++;
		}
		j--;
		return j;
	}

#endif
}
#endif
