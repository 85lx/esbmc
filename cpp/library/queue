/*******************************************************************\

Module:

Author: Lucas Cordeiro and Felipe Rodrigues

Date: September 2012

\*******************************************************************/

#ifndef STL_QUEUE
#define STL_QUEUE

#include "vector"
#include "deque"
#include "list"
#include "functional"

namespace std
{

  #define QUEUE_CAPACITY 100

  template < class T, class Container = vector<T>,
	class Compare = less<typename Container::value_type> >
  class priority_queue
	{
	public:
	  priority_queue ( );
	  explicit priority_queue ( const Compare& x, const Container& y );
	  //template <class InputIterator>
	    //       priority_queue ( InputIterator first, InputIterator last,
	      //                      const Compare& x = Compare(),
	        //                    const Container& y = Container() );
	  explicit priority_queue ( T* x, T* y );
	  void push ( const float& x );
	  bool empty ( ) const;
	  size_t size ( ) const;
	  const T& top ( ) const;
	  void pop ( );
	};

  template<class T, class Container = deque<T> > class queue
  {
    T buf[QUEUE_CAPACITY];
    int _size=0;
    int head=0;
    int tail=0;
	
    public:

    queue():_size(0), head(0), tail(0){}
    queue(std::deque<int>& x):_size(x.size()), head(0), tail(0){}
    queue(std::list<int>& x):_size(x.size()), head(0), tail(0){}

    void push ( const T& t )
    {
      assert(0 <= _size);
      __ESBMC_assert(_size < QUEUE_CAPACITY, "queue overflow");
      buf[tail] = t;
      _size++;
     if (tail == QUEUE_CAPACITY)
       tail = 1;
     else
       tail++;
    }

    bool empty ( ) const
    {
      if (head == tail) 
        return true;
      else 
	return false;
    }

    T& front ( )
    {
      assert(!empty());
      return buf[head];
    }

    int size() const
    {
      assert(0 <= _size && _size <= QUEUE_CAPACITY);
      return _size;
    }

    void pop()
    {
      __ESBMC_assert(size()>0, "queue underflow");
      _size--;
      if (head == QUEUE_CAPACITY) 
        head = 1;
      else 
        head++;
    }

    T& back ()
    {     
      assert(!empty());
      return buf[tail-1];
    }    
  };

}

#endif
