#ifndef __STL_MAP
#define __STL_MAP

#include <pair>
#include "iterator"
#include "iostream"

namespace std {

  template<class T>
  class less {};

  template < class Key, class T, class Compare = less<Key>,
             class Allocator = allocator<pair<const Key,T> > >
  class multimap{
  public:
	  typedef Key key_type;
	     typedef T mapped_type;
	     typedef pair<const Key, T> value_type;
	     typedef Compare key_compare;
	     typedef int size_type;

	     class iterator{
	       public:

	       iterator(const iterator&);
	       iterator();
	       iterator& operator=(const iterator&);

	       value_type * operator -> ();

	       value_type & operator * ();

	       iterator& operator ++ ();
	       iterator& operator ++ (int);

	       iterator& operator -- ();
	       iterator& operator -- (int);

	       bool operator == (const iterator& it) const;
	       bool operator != (const iterator& it) const;
	     };


	     class const_iterator{
	       public:
	       const_iterator(const const_iterator&);
	       const_iterator(iterator);
	       const_iterator();
	       const_iterator& operator=(const const_iterator&);

	       const value_type * operator -> ();

	       const value_type & operator * ();

	       const_iterator& operator ++ ();
	       const_iterator& operator ++ (int);

	       const_iterator& operator -- ();
	       const_iterator& operator -- (int);

	       bool operator == ( const const_iterator&)const;
	       bool operator != ( const const_iterator&)const;
	     };

	     class reverse_iterator{
	       public:
	       reverse_iterator(reverse_iterator);
	       reverse_iterator();
	       explicit reverse_iterator(iterator);

	       iterator base() const; // explicit

	       reverse_iterator& operator=(const reverse_iterator&);

	       value_type * operator -> ();

	       value_type & operator * ();

	       reverse_iterator& operator ++ ();
	       reverse_iterator& operator ++ (int);

	       reverse_iterator& operator -- ();
	       reverse_iterator& operator -- (int);

	       bool operator == ( const reverse_iterator&)const;
	       bool operator != ( const reverse_iterator&)const;
	     };

	     class  const_reverse_iterator {
	       public:
	       const_reverse_iterator(const_reverse_iterator);
	       const_reverse_iterator();
	       explicit const_reverse_iterator(const_iterator);

	       const_iterator base() const; // explicit

	       const_reverse_iterator& operator=(const const_reverse_iterator);

	       const value_type * operator -> ();

	       const value_type & operator * ();

	       const_reverse_iterator& operator ++ ();
	       const_reverse_iterator& operator ++ (int);

	       const_reverse_iterator& operator -- ();
	       const_reverse_iterator& operator -- (int);

	       bool operator == ( const const_reverse_iterator&)const;
	       bool operator != ( const const_reverse_iterator&)const;
	     };

	  explicit multimap ( const Compare& comp = Compare(),
	                 const Allocator& = Allocator() );
	  multimap ( const multimap<Key,T,Compare,Allocator>& x );
	  size_type count ( const key_type& x ) const;
	  iterator insert ( const value_type& x );
	  iterator insert ( iterator position, const value_type& x );
	  template <class InputIterator>
	     void insert ( InputIterator first, InputIterator last );
      iterator begin ();
      const_iterator begin () const;
      iterator end ();
      const_iterator end () const;
      template <class Key, class T, class Compare, class Allocator>
        bool operator== ( const multimap<Key,T,Compare,Allocator>& x,
                          const multimap<Key,T,Compare,Allocator>& y );
      template <class Key, class T, class Compare, class Allocator>
        bool operator<  ( const multimap<Key,T,Compare,Allocator>& x,
                          const multimap<Key,T,Compare,Allocator>& y );
      template <class Key, class T, class Compare, class Allocator>
        bool operator!= ( const multimap<Key,T,Compare,Allocator>& x,
                          const multimap<Key,T,Compare,Allocator>& y );
      template <class Key, class T, class Compare, class Allocator>
        bool operator>  ( const multimap<Key,T,Compare,Allocator>& x,
                          const multimap<Key,T,Compare,Allocator>& y );
      template <class Key, class T, class Compare, class Allocator>
        bool operator>= ( const multimap<Key,T,Compare,Allocator>& x,
                          const multimap<Key,T,Compare,Allocator>& y );
      template <class Key, class T, class Compare, class Allocator>
        bool operator<= ( const multimap<Key,T,Compare,Allocator>& x,
                          const multimap<Key,T,Compare,Allocator>& y );
  };

  template <class Key, class T, class Compare=less<Key> >
  class map {
    public:

    typedef Key key_type;
    typedef T mapped_type;
    typedef pair<const Key, T> value_type;
    typedef Compare key_compare;
    typedef int size_type;

    class iterator{
      public:

      iterator(const iterator&);
      iterator();
      iterator& operator=(const iterator&);

      value_type * operator -> ();

      value_type & operator * ();

      iterator& operator ++ ();
      iterator& operator ++ (int);

      iterator& operator -- ();
      iterator& operator -- (int);

      bool operator == (const iterator& it) const;
      bool operator != (const iterator& it) const;
    };


    class const_iterator{
      public:
      const_iterator(const const_iterator&);
      const_iterator();
      const_iterator& operator=(const const_iterator&);

      const value_type * operator -> ();

      const value_type & operator * ();

      const_iterator& operator ++ ();
      const_iterator& operator ++ (int);

      const_iterator& operator -- ();
      const_iterator& operator -- (int);

      bool operator == ( const const_iterator&)const;
      bool operator != ( const const_iterator&)const;
    };

    class reverse_iterator{
      public:
      reverse_iterator(reverse_iterator);
      reverse_iterator();
      explicit reverse_iterator(iterator);

      iterator base() const; // explicit

      reverse_iterator& operator=(const reverse_iterator&);

      value_type * operator -> ();

      value_type & operator * ();

      reverse_iterator& operator ++ ();
      reverse_iterator& operator ++ (int);

      reverse_iterator& operator -- ();
      reverse_iterator& operator -- (int);

      bool operator == ( const reverse_iterator&)const;
      bool operator != ( const reverse_iterator&)const;
    };

    class  const_reverse_iterator {
      public:
      const_reverse_iterator(const_reverse_iterator);
      const_reverse_iterator();
      explicit const_reverse_iterator(const_iterator);

      const_iterator base() const; // explicit

      const_reverse_iterator& operator=(const const_reverse_iterator);

      const value_type * operator -> ();

      const value_type & operator * ();

      const_reverse_iterator& operator ++ ();
      const_reverse_iterator& operator ++ (int);

      const_reverse_iterator& operator -- ();
      const_reverse_iterator& operator -- (int);

      bool operator == ( const const_reverse_iterator&)const;
      bool operator != ( const const_reverse_iterator&)const;
    };

    // iterators:
    iterator begin();
    const_iterator begin() const;
    iterator end();
    const_iterator end() const;
    reverse_iterator rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator rend();
    const_reverse_iterator rend() const;

    // capacity:
    bool empty() const;
    size_type size() const;
    size_type max_size() const;

    //element access:
    T& operator[](const key_type& x);

    // modifiers:
    pair<iterator, bool> insert(const value_type& x);
    //pair<iterator, bool> insert(const std::pair<Key,T>& x);
    iterator insert(iterator position, const value_type& x);

    void erase(iterator position);
    size_type erase(const key_type& x);
    void erase(iterator first, iterator last);
    void swap(map<Key,T,Compare>);
    void clear();

    // map operations:
    iterator find(const key_type& x);
    const_iterator find(const key_type& x) const;
    size_type count(const key_type& x) const;
    iterator lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    iterator upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    pair<iterator,iterator> equal_range(const key_type& x);
    pair<const_iterator,const_iterator> equal_range(const key_type& x) const;

    // comparators:

    bool operator == (const map<Key,T,Compare>&) const;
    bool operator != (const map<Key,T,Compare>&) const;
    bool operator >= (const map<Key,T,Compare>&) const;
    bool operator <= (const map<Key,T,Compare>&) const;
  };

  // specialized algorithms:
  template <class Key, class T, class Compare>
  void swap(map<Key,T,compare>&, vector<Key,T,compare>&);

}

#endif

