/*******************************************************************\

Module: 

Author: Felipe Rodrigues

Date: Feb 2012

\*******************************************************************/

#ifndef STL_STRING
#define STL_STRING

#include "definitions.h"
#include "cstring"
#include "ostream"
#include "istream"
#include "cassert"
#include "iostream"

size_t npos;

namespace std
{

	struct string
	{
		//const char *str;
		char *str;
		int _size;
	public:

		struct const_iterator{
		public:
		    const_iterator(const const_iterator&);
		    const_iterator();
		    const_iterator& operator=(const const_iterator&);

		    template<typename T>
		    const T* operator -> ();

		    template<class T>
		    const T& operator * ();
		    const_iterator& operator * ();

		    const_iterator& operator ++ ();
		    const_iterator& operator ++ (int);

		    const_iterator& operator -- ();
		    const_iterator& operator -- (int);

		    bool operator == ( const const_iterator&)const;
		    bool operator != ( const const_iterator&)const;

		    bool operator < ( const const_iterator&)const;
		    bool operator > ( const const_iterator&)const;

		    bool operator <= ( const const_iterator&)const;
		    bool operator >= ( const const_iterator&)const;

		    const_iterator operator + (int) const;
		    const_iterator operator - (int) const;

		    const_iterator& operator += (int);
		    const_iterator& operator -= (int);
		};

		string ();
		string (char*);
		string (const char * s, size_t n);
		string (string& s, size_t n);
		string (char c, size_t n);
		string::string(int len);
		char* c_str ( ) const;
	    const_iterator begin() const;
	    const_iterator end() const;
		bool operator== (string& b);
		bool operator== ( const char* lhs);
		bool operator== (string& a, string& b);
		bool operator== ( const char* lhs, string& rhs );
		bool operator== ( string& lhs, const char* rhs );
		bool operator!= (string& a);
		bool operator!= ( const char* lhs );
		bool operator!= ( const char* lhs, string& rhs );
		bool operator!= ( string& lhs, const char* rhs );
		bool operator> (string& a);
		bool operator> (const char* a);
		bool operator> ( const char* lhs, string& rhs );
		bool operator> ( string& lhs, const char* rhs );
		bool operator< (string& a);
		bool operator< (const char* a);
		bool operator< ( const char* lhs, string& rhs );
		bool operator< ( string& lhs, const char* rhs );
		bool operator>= (string& a);
		bool operator>= ( const char* lhs );
		bool operator<= (string& a);
		bool operator<= ( const char* lhs );
		string& operator= ( string& str );
		string& operator= ( const char* s );
		string& operator= ( char* s );
		string& operator= ( char c );
		string& operator+= ( string& s);
		string& operator += (const char* s);
		string& operator+= (char s);
		string& operator+ ( string& s);
		string& operator+ ( const char* s);
		string& operator+ ( char s);
		string& operator+ ( string& s1, string& s2);
		char& operator[] ( size_t pos );
		char& at ( size_t pos ) const;
		bool empty ( ) const;
		size_t length() const;
		int compare ( const string& s ) const;
		int compare ( const char* s ) const;
		int compare ( int pos1, size_t n1, string& s ) const;
		int compare ( int pos1, size_t n1, const char* s ) const;
		int compare ( size_t pos1, size_t n1, string& s, size_t pos2, size_t n2 ) const;
		string substr ( size_t pos, size_t npos ) const;
		string substr ( size_t npos ) const;
		size_t find_first_of ( const string& s, size_t pos = 0 ) const;
		size_t find_first_of ( const char* s, size_t pos = 0 ) const;
		size_t find_first_of ( char c, size_t pos = 0 ) const;
		size_t find ( const string& s, size_t pos = 0 ) const;
		size_t find ( const char* s, size_t pos = 0 ) const;
		size_t find ( const char* s, size_t pos = 0 , size_t n) const;
		size_t find ( char c, size_t pos = 0 ) const;
		string& assign ( string& s );
		string& assign ( const char* s, size_t n );
		string& assign ( string& s, size_t pos = 0, size_t n );
		string& assign ( const char* s );
		string& assign ( size_t n, char c );
		string& append ( string& s );
		string& append ( const char* s, size_t n );
		string& append ( string& s, size_t pos, size_t n );
		string& append ( const char* s );
		string& append ( size_t n, char c );
		void swap ( string& s );
		void resize ( size_t n, char c );
		void resize ( size_t n );
		size_t capacity ( ) const;
		size_t max_size ( ) const;
		int size() const;
		size_t rfind ( const string& s, size_t pos = npos ) const;
		size_t rfind ( const char* s, size_t pos = npos ) const;
		size_t rfind ( char c, size_t pos = npos ) const;
		size_t find_last_of ( const string& s, size_t pos = npos ) const;
		size_t find_last_of ( const char* s, size_t pos = npos ) const;
		size_t find_last_of ( char c, size_t pos = npos ) const;
		size_t find_first_not_of ( const string& s, size_t pos = 0 ) const;
		size_t find_first_not_of ( const char* s, size_t pos = 0 ) const;
		size_t find_first_not_of ( char c, size_t pos = 0 ) const;
		string& erase ( size_t pos = 0, size_t n = npos );
		string& erase ( size_t pos = 0, size_t n = npos, char* tmp );
		string& replace ( size_t pos1, size_t n1,   const string& s );
		string& replace ( size_t pos1, size_t n1, string& s, size_t pos2, size_t n2 );
		string& replace ( size_t pos1, size_t n1, char* s, size_t pos2, size_t n2 );
		string& replace ( size_t pos1, size_t n1,   const char* s, size_t n2 );
		string& replace ( size_t pos1, size_t n1,   const char* s );
		string& replace ( size_t pos1, size_t n1,   size_t n2, char c );
		string& insert ( size_t pos1, string& s );
		string& insert ( size_t pos1, const string& s, size_t pos2, size_t n );
		string& insert ( size_t pos1, const char* s, size_t n);
		string& insert ( size_t pos1, const char* s );
		string& insert ( size_t pos1, size_t n, char c );
		size_t copy ( char* s, size_t n, size_t pos = 0) const;
		const char* data() const;
	};
}

namespace std
{

	string::string ()
	{
		str=new char[1];
		str="";
		_size = 0;
		//npos = 0;
		//str2=NULL;
	}
	string::string (char *s)
	{
		__ESBMC_HIDE:
		_size=strlen(s); //length of string
		str=new char[_size+1]; //increments length of string
		npos = _size-1;
		strcpy(str,s);
	}
	string::string (const char * s, size_t n)
	{
		__ESBMC_HIDE: //length of string
		//__ESBMC_assert(n < strlen(s),"string overflow");
		int i;
		str=new char[n+1]; //increments length of string
		_size = n;
		for(i=0;(i<_size)&&(s[i]!='\0');i++)
			str[i]=s[i];
		str[i]='\0';
	}
	string::string (string& s, size_t n)
	{
		__ESBMC_HIDE: //length of string
		int i;
		str=new char[n+1]; //increments length of string
		_size = n;
		if(n>s.length())
			n=s.length();
		for(i=0;i<_size;i++)
			str[i]=s.str[i];
		str[i]='\0';
	}
	 string::string(int len)
	 {
	     str = new char [len+1];
	     //for(int i = 0; i <= len; i++)
	         //str[i] = '\0';
	     _size = len;
	     //npos = _size-1;string_operator[]_5/test.desc
	 }
	 string::string(char c, size_t n)
	 {
	     str = new char [n+1];
	     for(int i = 0; i <= n; i++)
	         str[i] = c;
	     _size = n;
	     //npos = _size-1;string_operator[]_5/test.desc
	 }
	char* string::c_str () const
	{
		__ESBMC_HIDE:
		return str;
	}
	inline string::ostream& operator << (ostream& o, string)
	{
		return o;
	}
	inline string::ostream& operator << (ostream& o, struct const_iterator&)
	{
		return o;
	}
	inline string::istream& operator >> (istream& is, string)
	{
		return is;
	}
#if 1
	bool string::operator== (string& b)
	{
		__ESBMC_HIDE:
               if (strcmp(this->str, b.str) == 0)
                    return true;
               else
                    return false;
	}
	bool string::operator== ( const char* lhs)
	{
		__ESBMC_HIDE:
		int aux,i;
		aux = strcmp((char*)lhs, this->str);
		if (aux == 0){
			return true;
		}else{
			return false;
		}
	}
	bool string::operator== (string& a, string& b)
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp(b.c_str(), a.c_str());
		if (aux == 0){
			return true;
		}else{
			return false;
		}
	}
	bool string::operator== ( const char* lhs, string& rhs )
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp((char*)lhs, rhs.c_str());
		if (aux == 0){
			return true;
		}else{
			return false;
		}
	}
	bool string::operator== ( string& lhs, const char* rhs )
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp(lhs.c_str(), (char*)rhs);
		if (aux == 0){
			return true;
		}else{
			return false;
		}
	}
	bool string::operator!= (string& a)
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp(a.c_str(), this->c_str());
		if (aux == 0){
			return false;
		}else{
			return true;
		}
	}
	bool string::operator!= ( const char* lhs )
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp((char*)lhs, this->c_str());
		if (aux == 0){
			return false;
		}else{
			return true;
		}
	}
	bool string::operator!= ( const char* lhs, string& rhs )
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp((char*)lhs, rhs.c_str());
		if (aux == 0){
			return false;
		}else{
			return true;
		}
	}
	bool string::operator!= ( string& lhs, const char* rhs )
	{
		__ESBMC_HIDE:
		int aux;
		aux = strcmp(lhs.c_str(), (char*)rhs);
		if (aux == 0){
			return false;
		}else{
			return true;
		}
	}
	bool string::operator> (string& a)
	{
		__ESBMC_HIDE:
		if ( this->length() > a.length() )
			return true;
		return false;
	}
	bool string::operator> (const char* a)
	{
		__ESBMC_HIDE:
		if ( this->length() > strlen(a) )
			return true;
		return false;
	}
	bool string::operator> ( const char* lhs, string& rhs )
	{
		__ESBMC_HIDE:
		if ( strlen(lhs) > rhs.length() )
			return true;
		return false;
	}
	bool string::operator> ( string& lhs, const char* rhs )
	{
		__ESBMC_HIDE:
		if ( lhs.length() > strlen(rhs) )
			return true;
		return false;
	}
	bool string::operator< (string& a)
	{
		__ESBMC_HIDE:
		if ( this->length() < a.length() ){
			return true;
		}else{
			return false;
		}
	}
	bool string::operator< (const char* a)
	{
		__ESBMC_HIDE:
		if ( this->length() < strlen(a) )
			return true;
		return false;
	}
	bool string::operator< ( const char* lhs, string& rhs )
	{
		__ESBMC_HIDE:
		if ( strlen(lhs) < rhs.length() )
			return true;
		return false;
	}
	bool string::operator< ( string& lhs, const char* rhs )
	{
		__ESBMC_HIDE:
		if ( lhs.length() < strlen(rhs) )
			return true;
		return false;
	}
	bool string::operator >=(string& a)
	{
		__ESBMC_HIDE:
		if ( this->length() >= a.length() )
			return true;
		return false;
	}
	bool string::operator>= ( const char* lhs )
	{
		__ESBMC_HIDE:
		if ( this->length() >= (strlen(lhs)) )
			return true;
		return false;
	}
	bool string::operator <=(string& a)
	{
		__ESBMC_HIDE:
		if ( this->length() <= a.length() )
			return true;
		return false;
	}
	bool string::operator <=(const char* lhs)
	{
		__ESBMC_HIDE:
		if ( this->length() <= strlen(lhs) )
			return true;
		return false;
	}
	size_t  string::length() const
	{
		return this->_size;
	}
	char& string::operator[](size_t pos)
	{
		__ESBMC_assert( (pos>=0) && (pos<this->_size) , "Error! Invalid access memory area");
	    if (pos > this->_size)
	        return this->str[this->_size-1];
	    else
	        return this->str[pos];
	}
	char& string::at ( size_t pos ) const
	{
		__ESBMC_assert( (pos>=0) && (pos<this->_size) , "Error! Invalid access memory area");
		int i;
		if (pos>this->length()) {
			throw("out_of_range");
		}
		else {
			return (char&) this->str[pos];
		}
	}
	bool string::empty ( ) const
	{
		//assert(this->_size == );
		if (this->_size == 0)
			return true;
		return false;
	}
	string& string::operator= ( string& str )
	{
		__ESBMC_HIDE:
		this->_size=str.length();
		this->str=new char[this->_size+1];
		strcpy(this->str, str.str);
		return *this;
	}
	string& string::operator= ( const char* s )
	{
		this->_size=strlen(s);
		this->str=new char[this->_size+1];
		return string(strcpy(this->c_str(), s));
	}
	string& string::operator= ( char* s )
	{
		this->_size=strlen(s);
		this->str=new char[this->_size+1];
		return string(strcpy(this->c_str(), s));
	}
	string& string::operator= ( char s )
	{
		this->_size=1;
		this->str=new char[this->_size+1];
		this->str[0] = s;
		this->str[1] = '\0';
		return *this;
	}
	string& string::operator+=( string& s)
	{
	    int rhsLen = s._size;
      int lhsLen = this->_size;
	    int totalLen = lhsLen + rhsLen;
	    char temp[totalLen+1];
	    int i, j, k;
	    for (i=0; i<lhsLen; i++)
	        temp[i] = this->str[i];
      temp[i]='\0';
	    for(j=i, k=0; j<totalLen; j++, k++)
	    	temp[j] = s.str[k];
      temp[j]='\0';
      this->str = new char[totalLen];
      this->_size = totalLen;
      strcpy(this->str, temp);
	    return *this;
	}
	string& string::operator+= (const char* s)
	{
	    int rhsLen = strlen(s);
      int lhsLen = this->_size;
	    int totalLen = lhsLen + rhsLen;
	    char temp[totalLen+1];
	    int i, j, k;
	    for (i=0; i<lhsLen; i++)
	        temp[i] = this->str[i];
      temp[i]='\0';
	    for(j=i, k=0; j<totalLen; j++, k++)
	    	temp[j] = s[k];
      temp[j]='\0';
      this->str = new char[totalLen];
      this->_size = totalLen;
      strcpy(this->str, temp);
	    return *this;
	}
	string& string::operator+= (char s)
	{
	    int totalLen = this->_size +1;
	    char temp[totalLen+1];
	    int i, j, k;
	    for (i=0; i<this->_size; i++)
	        temp[i] = this->str[i];
	    temp[i] = s;
	      this->str = new char[totalLen];
	      this->_size = totalLen;
	      strcpy(this->str, temp);
		    return *this;
	}
	string& string::operator+ ( string& s)
	{
		__ESBMC_HIDE:
	    int rhsLen = s._size;
	    int totalLen = this->_size + rhsLen;
	    string temp(totalLen);
	    int i, j, k;
	    for (i=0; i<this->_size; i++)
	        temp[i] = this->str[i];
	    for(j=i, k=0; j<temp._size; j++, k++)
	    	temp.str[j] = s.str[k];
	    //*this = temp;
	    //assert(temp==s);
	    //assert(temp == "TeTestTest");
	    return temp;
	}
	string& string::operator+ ( const char* s)
	{
		__ESBMC_HIDE:
	    int rhsLen = strlen(s);
	    int totalLen = this->_size + rhsLen;
	    string temp(totalLen);
	    int i, j, k;
	    for (i=0; i<this->_size; i++)
	        temp[i] = this->str[i];
	    for(j=i, k=0; j<temp._size; j++, k++)
	    	temp.str[j] = s[k];
	    //*this = temp;
	    //assert(temp==s);
	    //assert(temp == "TeTestTest");
	    return temp;
	}
	string& string::operator+ ( char s)
	{
		__ESBMC_HIDE:
	    string temp(this->_size+1);
	    temp.str[temp._size-1] = s;
	    //*this = temp;
	    //assert(temp==s);
	    return temp;
	}
//	string& string::operator+ ( string& s1, string &s2)
//	{
//
//		__ESBMC_HIDE:
//	    int rhsLen = s._size;
//	    int totalLen = this->_size + rhsLen;
//	    string temp(totalLen);
//	    int i, j, k;
//	    for (i=0; i<this->_size; i++)
//	        temp[i] = this->str[i];
//	    for(j=i, k=0; j<temp._size; j++, k++)
//	    	temp.str[j] = s.str[k];
//	    *this = temp;
//	    return *this;
//	}
	void string::swap ( string& s )
	{
		string aux(s.str);
		s.str = this->str;
		s._size = this->_size;
		this->str = aux.str;
		this->_size = aux._size;
	}
	size_t string::capacity ( ) const
	{
		return this->_size;
	}
	size_t string::max_size ( ) const;
	int string::size() const
	{
		return this->_size;
	}
	void string::resize ( size_t n )
	{
		int num = this->_size,i;
		string tmp(this->str);
		this->_size= n;
		this->str=new char[n];
		for(i=0;i<num;i++)
			this->str[i] = tmp.str[i];
	}
	void string::resize ( size_t n, char c )
	{
		int num, i;
		num = this->length();
		string tmp(this->str);
		this->_size= n;
		this->str=new char[n];
		for(i=0;i<num;i++)
			this->str[i] = tmp.str[i];
		for(i=num;i<(this->_size-2);i++)
			this->str[i] = c;
	}
	string& string::assign ( string& s )
	{
		*this=s;
		return *this;
	}
	string& string::assign ( string& s, size_t pos = 0, size_t n )
	{
		this->_size=(n);
		this->str=new char[this->_size+1];
		strncpy(this->str, s.str+pos, n);
		return *this;
	}
	string& string::assign ( const char* s, size_t n )
	{
		this->_size=(n);
		this->str=new char[this->_size];
		strncpy(this->str, s, n);
		return *this;
	}
	string& string::assign ( const char* s )
	{
		*this=s;
		return *this;
	}
	string& string::assign ( size_t n, char c )
	{
		int i;
		this->_size = n;
		this->str = new char[n];
		for (i = 1;i<n;i++){
			this->str[i] = c;
		}
		return *this;
	}
	size_t string::copy ( char* s, size_t n, size_t pos = 0) const
	{
		size_t aux = n + pos;
		if (pos>this->size()){
			throw("out_of_range");
		}
		strncpy(s, this->c_str()+pos, aux);
		return n;
	}
	const char* string::data() const
	{
		return this->str;
	}
	string& string::append (  string& s )
	{
		*this += s;
		return *this;
	}
	string& string::append ( const char* s, size_t n )
	{
		if( n > strlen(s) )
			throw("out_of_range");
	    int rhsLen = n;
	    int totalLen = this->_size + rhsLen;
	    string temp(totalLen);
	    int i, j, k;
	    for (i=0; i<this->_size; i++)
	        temp[i] = this->str[i];
	    for(j=i, k=0; j<temp._size; j++, k++)
	    	temp.str[j] = s[k];
	    *this = temp;
	    return *this;
	}
	string& string::append ( string& s, size_t pos, size_t n )
	{
		if( (pos > s._size) || (n > (s._size-pos)) )
			throw("out_of_range");

	    int rhsLen = n;
	    int totalLen = this->_size + rhsLen;
	    string temp(totalLen);
	    int i, j, k;
	    for (i=0; i<this->_size; i++)
	        temp[i] = this->str[i];
	    for(j=i, k=pos; j<temp._size; j++, k++)
	    	temp.str[j] = s.str[k];
	    *this = temp;
	    return *this;
	}
	string& string::append ( const char* s )
	{
	    int rhsLen = strlen(s);
	    int totalLen = this->_size + rhsLen;
	    string temp(totalLen);
	    int i, j, k;
	    for (i=0; i<this->_size; i++)
	        temp[i] = this->str[i];
	    for(j=i, k=0; j<temp._size; j++, k++)
	    	temp.str[j] = s[k];
	    *this = temp;
	    return *this;
	}
	size_t string::find ( char c, size_t pos = 0 ) const
	{
		return strspn(str+pos,(const char*)c);
	}
	size_t string::find ( const string& s, size_t pos = 0 ) const
	{
		return strspn(str+pos,s.c_str());
	}
	size_t string::find ( const string& s, size_t pos = 0 ) const
	{
		return strspn(str+pos,s.c_str());
	}
	size_t string::find ( const char* s, size_t pos = 0 ) const
	{
		return strspn(str+pos,s);
	}

#if 0

	size_t string::find ( const char* s, size_t pos = 0 , size_t n) const
	{
		__ESBMC_assert((strlen(s)<=this->_size)&&(pos<this->_size)&&(n-pos<this->_size), "string overflow");
		return strspn(str+pos,s);
	}


	string& string::append ( size_t n, char c )
	{
		int i;
		char* tmp;
		tmp=new char[n];

		for (i = 0;i<n;i++){
			tmp[i] = c;
		}

		//assert(strlen(tmp)==10);
	    int rhsLen = strlen(tmp);
	    int totalLen = this->_size + rhsLen;
	    string temp(totalLen);
	    int i, j, k;
	    for (i=0; i<this->_size; i++)
	        temp[i] = this->str[i];
	    for(j=i, k=0; j<temp._size; j++, k++)
	    	temp.str[j] = tmp[k];
	    *this = temp;
	    return *this;
	}









	int string::compare ( const string& s ) const
	{
		__ESBMC_HIDE:
		if(s.length() > this->length())
		   return 1;
		if(s.length() < this->length())
		   return -1;
		return strcmp(s.c_str(),this->c_str());
	}
	int string::compare ( const char* s ) const
	{
		__ESBMC_HIDE:
		if(strlen(s) > this->length())
		   return 1;
		if(strlen(s) < this->length())
		   return -1;
		return strcmp(s,this->c_str());
	}
	int string::compare ( int pos1, size_t n1, string& s ) const
	{
		__ESBMC_HIDE:
		char* aux;

		aux = strncpy(s.c_str2(),str+pos1,n1);

		if(strlen((const char*)aux) > this->length())
		   return 1;
		if((const char*)aux < this->length())
		   return -1;
		return strcmp((const char*)aux,this->c_str());
	}
	int string::compare ( int pos1, size_t n1, const char* s ) const
	{
		__ESBMC_HIDE:
		char* aux;

		aux = strncpy((char*)s,str+pos1,n1);

		if(strlen((const char*)aux) > strlen(s))
		   return 1;
		if((const char*)aux < strlen(s))
		   return -1;
		return strcmp((const char*)aux,s);
	}
	int string::compare ( size_t pos1, size_t n1, string& s, size_t pos2, size_t n2 ) const
	{
		__ESBMC_HIDE:
		char* aux;
		char* aux2;

		aux = strncpy(s.c_str2(),str+pos1,n1);
		aux2 = strncpy(str2,str+pos2,n2);

		if(strlen((const char*)aux) > strlen((const char*)aux2))
		   return 1;
		if((const char*)aux < strlen((const char*)aux2))
		   return -1;
		return strcmp((const char*)aux,(const char*)aux2);
	}
	string string::substr ( size_t pos, size_t npos ) const
	{
		__ESBMC_HIDE:
		char* s;
		return string(strncpy(s,str+pos,npos));
	}

	string string::substr ( size_t pos) const
	{
		__ESBMC_HIDE:
		char* s;
		return string(strncpy(s,str,pos));
	}
	size_t string::find_first_of ( const string& s, size_t pos = 0 ) const
	{
		return strcspn(s.c_str(), str+pos);
	}
	size_t string::find_first_of ( const char* s, size_t pos = 0 ) const
	{
		return strcspn(s, str+pos);
	}
	size_t string::find_first_of ( char c, size_t pos = 0 ) const
	{
		__ESBMC_HIDE:
		char *aux;
		aux = strchr(str+pos, c);
		if(aux!=0)
			return 1;
		return 0;
	}


	size_t string::rfind ( const string& s, size_t pos = npos ) const
	{
		return strspn_reverse(s.c_str(), str+pos);
	}
	size_t string::rfind ( const char* s, size_t pos = npos ) const
	{
		return strspn_reverse(str, s+pos);
	}
	size_t string::rfind ( char c, size_t pos = npos ) const
	{
		return strspn_reverse((const char *)c, str+pos);
	}
	size_t string::find_last_of ( const string& s, size_t pos = npos ) const
	{
		return strspn_reverse(s.c_str(), str+pos);
	}
	size_t string::find_last_of ( const char* s, size_t pos = npos ) const
	{
		return strspn_reverse(str, s+pos);
	}
	size_t string::find_last_of ( char c, size_t pos = npos ) const
	{
		return strspn_reverse((const char *)c, str+pos);
	}
	size_t string::find_first_not_of ( const string& s, size_t pos = 0 ) const
	{
		__ESBMC_assert(pos>this->length(), "overflow");
		int i=0,j=0;
		const char* tmp = this->c_str();
		const char* tmp2 = s.c_str();
		while(tmp2[i]!='\0')
		{
			while(tmp[j]!='\0')
			{
				if (tmp[j] != tmp2[i])
					return j;
				j++;
			}
			i++;
		}
		j--;
		return j;
	}
	size_t string::find_first_not_of ( const char* s, size_t pos = 0 ) const
	{
		__ESBMC_assert(pos>this->length(), "overflow");
		int i=0,j=0;
		const char* tmp = this->c_str();
		while(s[i]!='\0')
		{
			while(tmp[j]!='\0')
			{
				if (tmp[j] != s[i])
					return j;
				j++;
			}
			i++;
		}
		j--;
		return j;
	}
	size_t string::find_first_not_of ( char c, size_t pos = 0 ) const
	{
		__ESBMC_assert(pos>this->length(), "overflow");
		int j=0;
		const char* tmp = this->c_str();
		while(tmp[j]!='\0')
		{
			if (tmp[j] != c)
				return j;
			j++;
		}
		j--;
		return j;
	}
	string& string::erase ( size_t pos = 0, size_t n = npos )
	{
		__ESBMC_HIDE:
		__ESBMC_assert((pos > this->length()) && ((pos+n)>this->length()), "overflow");
		int i,j=pos;
		char* tmp = (char *)this->c_str();
		for(i=pos;i<(pos+n);i++)
		{
			while(j!=this->length())
			{
				tmp[j] = tmp[j+1];
				j++;
			}
			j=pos;
		}
		return string(tmp);
	}
	string& string::erase ( size_t pos = 0, size_t n = npos, char* tmp )
	{
		__ESBMC_HIDE:
		__ESBMC_assert((pos > strlen(tmp)) && ((pos+n)>strlen(tmp)), "overflow");
		int i,j=pos;
		for(i=pos;i<(pos+n);i++)
		{
			while(j!=strlen(tmp))
			{
				tmp[j] = tmp[j+1];
				j++;
			}
			j=pos;
		}
		return string(tmp);
	}
	string& string::replace ( size_t pos1, size_t n1,   const string& s )
	{
		__ESBMC_HIDE:
		string tmp = this->erase(pos1,n1);
		tmp.insert(pos1,s.c_str());
		return tmp;
	}
	string& string::replace ( size_t pos1, size_t n1, string& s, size_t pos2, size_t n2 )
	{
		string tmp = this->erase(pos1,n1);
		string tmptwo = s.erase(pos2,n2);
		tmp.insert(pos1,tmptwo.c_str());
		return tmp;
	}
	string& string::replace ( size_t pos1, size_t n1, char* s, size_t pos2, size_t n2 );
	string& string::replace ( size_t pos1, size_t n1, const char* s, size_t n2 )
	{
		string tmp = this->erase(pos1,n1);
		string tmptwo = erase(0,n2,(char*)s);
		tmp.insert(pos1,tmptwo.c_str());
		return tmp;
	}
	string& string::replace ( size_t pos1, size_t n1,   const char* s )
	{
		string tmp = this->erase(pos1,n1);
		tmp.insert(pos1,s);
		return tmp;
	}
	string& string::replace ( size_t pos1, size_t n1,   size_t n2, char c )
	{
		string tmp = this->erase(pos1,n1);
		tmp.insert(pos1,n2,c);
		return tmp;
	}
	string& string::insert ( size_t pos1, string& s )
	{
		__ESBMC_HIDE:
		__ESBMC_assert(pos1 > this->length(), "overflow");
		return string(strcpy(this->c_str2()+pos1, s.c_str()));
	}
	string& string::insert ( size_t pos1, const string& s, size_t pos2, size_t n )
	{
		__ESBMC_HIDE:
		__ESBMC_assert((pos1) > this->length(), "overflow");
		__ESBMC_assert((pos2+n) > s.length(), "overflow");
		string aux = s.substr(pos2, n);
		return string(strcpy(this->c_str2()+pos1, aux.c_str()));
	}
	string& string::insert ( size_t pos1, const char* s, size_t n)
	{
		__ESBMC_HIDE:
		char* tmp;
		__ESBMC_assert(pos1 > this->length(), "overflow");
		__ESBMC_assert(n > strlen(s), "overflow");
		string aux = string(strncpy(tmp,s,npos));
		return string(strcpy(this->c_str2()+pos1, aux.c_str()));
	}
	string& string::insert ( size_t pos1, const char* s )
	{
		__ESBMC_HIDE:
		__ESBMC_assert(pos1 > this->length(), "overflow");
		return string(strcpy(this->c_str2()+pos1, s));
	}
	string& string::insert ( size_t pos1, size_t n, char c )
	{
		int i;
		char *aux = "";
		int tmp = n - this->length();
		if (tmp >0){
			for (i = 1;i<10;i++){
				aux +=c;
			}
		}
		return string(strcpy(this->c_str2()+pos1, aux));
	}


#endif
#endif
}
#endif

