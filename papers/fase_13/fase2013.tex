%\documentclass[oribibl,runningheads,a4paper]{llncs}
\documentclass[a4paper]{llncs}
\usepackage{url}
\usepackage{times}

\newcommand{\comment}[1]{}
\newcommand{\citenot}[1]{}
\newcommand{\blurb}[1]{{\texttt{[.. #1..]}}}


\begin{document}

%\mainmatter  % start of an individual contribution

%\title{Context-Bounded Symbolic Model Checking with ESBMC 1.17}
\title{SMT-Based Bounded Model Checking of C++ Programs}
%\subtitle{(Competition Contribution)}
%\title{TACAS'12 Competition Entry: ESBMC v1.17}
%\title{Software Verification Competition: ESBMC v1.17}
%\title{TACAS'12 Software Verification Competition: ESBMC v1.17}
%\title{System Description: ESBMC v1.17}
%\title{System Description: ESBMC v1.17 (TACAS'12 Competition version)}
%\titlerunning{}
\comment{
\author{Lucas Cordeiro$^1$ \and
	Jeremy Morse$^2$   \and
	Denis Nicole$^2$   \and
	Bernd Fischer$^2$}
\authorrunning{Lucas Cordeiro, Jeremy Morse, Denis Nicole, Bernd Fischer}
\institute{
  $^1$ Electronic and Information Research Center, %\\
  Federal University of Amazonas, Brazil\\
  %\url{lucascordeiro@ufam.edu.br}
  %\\\smallskip
  $^2$ Electronics and Computer Science, %\\
  University of Southampton, UK\\
  %\url{{jcmm106,dan,bf}@ecs.soton.ac.uk}
  %\url{http://www.ecs.soton.ac.uk}
  \url{esbmc@ecs.soton.ac.uk}
}
}

\maketitle

\begin{abstract}
Bounded model Checking (BMC) of C++ programs presents greater complexity than C programs due to features that the languages offers, such as templates, containers and exception handling. We present ESBMC, a bounded model checker for C and C++ programs, which encodes the verification conditions using different background theories and passes them directly to an SMT Solver. Our experimental results show that our approach can handle more constructs of the C++ programs and substantially reduce the verification time. 
\end{abstract}

\section{Introduction}
%
Introduction here (Lucas)...

\section{Background}
%
Background here (Lucas)...

\section{SMT-Based BMC for C++ Software}
%

\section{Standard Template Libraries}
\subsection{Introduction}
\\ \\
	Several applications have C++ as its basic programming language, including verification tools, information retrieval machines, databases, simulators, embedded systems and telecommunication systems. Compared to C, this programming language provides a wider set of features, libraries and functionalities that would require a way larger codification in the basic version of this language. This features include OOP (Object-oriented programming), specialized input-output libraries (stream libraries, in general), the template concept ,including STL containers, which have some of the popular data structures in Computing Science, plus making possible the use of any data type, thanks to template usage. 
\\ \\
	Systems that make use of this language (and its functionalities) require strong and steady software verification, for its errors become harder to find, as its own structure grows. 
\\ \\
	For this kind of operation, verification software is becoming more important and critical, especially its crucial characteristics (speed, accuracy, efficiency, friendliness). Many verifying systems are available, especially in high-level test. In a particular approach, STL verification become very useful as the system needs grows, for its practicality and encapsulated features accelerates the programming process, shortening the auxiliary implementation (like data structures creation, sort algorithms, search functions), helping the programmer focus on what matters.
\\ \\
	Of course, if C++ seems to be a more complex version of C, its verification will be more complex as well. Our solution involves the usual C code verification, using SMT-based bounded model-checking (ESBMC), and an operational model of the C++ libraries. In this session, we will focus on the STL sequential containers operational model, its preconditions and simulation features (like how we store the elements values of the containers and intern class methods), and how this is used to verify a C++ program code.
\\ \\
\subsection{Structure}
\\
	The structure of STL containers is based on the C++ structure itself, including its classes, operators, methods, functions and intern variables. It is divided in: iterations, capacity, element access, modifiers and unique members. The similarities and differences between sequential containers are described at Table 1.
	
\begin{table}
	\centering
		\begin{tabular}
			
		\end{tabular}
	\caption{STL sequential containers}
	\label{tab:STLSequentialContainers}
\end{table}
	
	\subsection{Model Semantics}
	
	Let us consider that a container model is composed by five types of variables, \emph{I}, \emph{C}, \emph{N}, \emph{P} and \emph{T}. \emph{I} represents a iterator that points to a position in the container, \emph{C} represents the container itself, N represents natural integer numbers used in the container, like size, capacity and elements index, \emph{P} represents the memory address where \emph{T} is located, and \emph{T} represents de values stored in the container. For convention, we assume that \emph{\{c, v, d, l\}} \subset C$,$ \{i, j, n\} \subset N $and$ \{it1, it2\} \subset I. 
	
	
	The containers contain an array of elements \emph{T}, and their positions in the memory are represented by pointers \emph{P}.
Assuming this, the syntax for integer expression is:\\ \\

	\emph{
	\textit{Int} = N \left| Z\\
		\left| C.size \left| C.capacity\\
		\left| \textit{Int} ( + \left| ? \left| * \left| ...) \textit{Int} $\\$ 
   	\left|\textit{It} ( + \left| - ) \textit{It}\\
	}
	
 \\ \\ 

	Similarly, the syntax for iterator expressions is:
	\\ \\
	\emph{
		\textit{It} = I \left| \textit{It} ( + \left| - ) \textit{It} \\
		\left| \textit{C}.begin \left| \textit{C}.end \\
		}

%	For \emph{P} (memory address values), the syntax is as follows:
%	\\ \\
%	\emph{
%		\textit{P} = p \left| \textit{It}.pointer \left| \textit{C}.array
%		\left| \textit{It}.source
%		\left| \textit{P} ( + \left| - ) \textit{P}
%	}
%\\ \\
%	The syntax for \emph{T} values is the following: 
%\\ \\
%\emph{	
%	\textit{T} = t \left| *\textit{It} \left| *\textit{P} \left| \textit{C}_int
%	}
%	\\ \\
%	To test the assertions, we use Booleans expressions, with the following syntax: 
%	\\ \\
%		Bool = Int ( < | > | = | … ) Int 
%| It ( < | > | = | … ) It
%| T  =  T
% | Assert | Assert (_| ^| ...) Assert
%|    var . Assert | E var . Assert

\subsection{Model}
	\emph{To simulate appropriately the containers, our model makes use of three variables: a variable \textit{P} called array, that points to the first element of the elements array, a natural value size, that stores the quantity of elements contained in the container, and a natural value capacity, that stores the total capacity of a container (valid onliy for vectors). Note that, as the elements are added in the container (specifically in vectors) and the size grows, the capacity also grows at a rate of 2*size, every time the size reaches the capacity value. \\ \\
	Similarly, iterators are modeled using three representing variables: a variable P called pointer, which contains the memory address to the correspondent element \textit{T} in the container, a variable N called position, which contains the index value pointed by the iterator, in the container, and a variable P called source, which contains the memory address correspondent to the first element \textit{T} stored in the container.\\ \\
	The vector container model has a structure as it follows: \\ \\}
	
\emph{	C1 = \{P1, C1.size, C1.capacity\}}
\\ \\
	Where P1 is a memory address where it is stored the elements of the container, C1.size is the total number of elements in the container, and C1.capacity is the total capacity of the vector, simulated internally in the model. \\ \\
	The main methods of a vector (and sequential containers, in general) have only three types of operation: insertion, exclusion and search. Methods like push-back(), pop-back(), front(), back(), push-front() and pop-front() are only a simplified variation of those main methods, optimized for some containers (like pop-back in a stack).
\\ \\
	An insert method is represented by the following structure:
\\ \\
	C{cont}\\
	It{cont.insert}|cont.insert\\
	It{position} & It{first} & It{last}\\
	P{point1} & P{point2}\\
	T{value}\\
	N{quantity}\\
	cont.insert (position, value)\\
		cont'.size = cont.size + 1\\
		*position = value\\
	|cont.insert(position, value, quantity)\\
		cont'.size = cont.size + quantity\\
		*(position + N(0 -> quantity)) = value\\
	|insert(position, first, last)\\
		cont'.size = cont.size +( last - first)\\
		*position = *first\\
	|insert(position, point1, point2)\\
		cont'size = cont.size + (point2 - point1)\\
		*position = *point1\\
		\\ \\
	Similarly, an erase method is structured like the following:
	\\ \\
	C{cont}\\
	It{cont.erase}|cont. erase\\
	It{position} & It{first} & It{last}\\
	P{point1} & P{point2}\\
	cont. erase (position)\\
		cont'.size = cont.size - 1\\
		position' = position + 1\\
	|cont. erase (position, first, last)\\
		cont'.size = cont.size -(last - first)\\
		position' = last\\
		\\ \\
	Searches are made in a container by using reference operators and a pointing type (pointer or iterator), and return the reference value (the element stored itself).
	\\ \\
	C{cont}\\
	It{i}\\
	N{n}\\
	T{C[n]}\\
	T{*i}\\
	\\ \\
	The structure of iterators is treated differently from the other types. The model is the following:\\ \\
	
	It : P{pointer}; N{pos}; P{cont_pos}\\ \\

	Where pointer is a memory address that points to the real position of the required element in the container (pointed by the iterator), pos is the iterator index internally in the container, and cont_pos is a memory address equivalent to cont.buf, being cont the container pointed by the iterator.
\\ \\

\section{Experimental Results}
%
Experimental Results here (Mauro)...



\section{Related Work}
%
Related Work here (Mauro and Mikhail)

\section{Conclusions}
%
Conclusions here (Lucas)...


\smallskip{\small\noindent{\bf Acknowledgments.} 
%
Acknowledgments here (Lucas)...
}

\vspace{-2.5ex}
\renewcommand\refname{{\normalsize References}}
{\begin{thebibliography}{10}
\vspace{-0.5ex}

%\bibitem{Boolector09}
%R.~Brummayer and A.~Biere
%\newblock Boolector: An efficient {SMT} solver for bit-vectors and arrays
%\newblock {\em TACAS}, {\em LNCS} 5505, pp. 174--177, 2009.

\bibitem{Cimatti10}
A.~Cimatti, A.~Micheli, I.~Narasamdya, and M.~Roveri.
\newblock Verifying {SystemC}: a software model checking approach.
\newblock {\em FMCAD}, 2010, pp.\ 121--128.

\bibitem{Clarke04}
%E.~Clarke et~al.
E.~Clarke, D.~Kroening, and F.~Lerda.
\newblock A tool for checking {ANSI-C} programs.
\newblock {\em TACAS}, {\em LNCS} 2988, pp.\ 168--176, 2004.

\bibitem{CordeiroPhD}
L.~Cordeiro.
\newblock {SMT}-Based Bounded Model Checking of Multi-Threaded Software in 
Embedded Systems.
\newblock PhD Thesis, U Southampton, 2011.

\bibitem{Cordeiro09}
L.~Cordeiro, B.~Fischer, and J.~Marques-Silva.
\newblock {SMT}-based bounded model checking for embedded {ANSI-C} software.
\newblock {\em ASE}, pp.\ 137--148, 2009. 
%\newblock Extended version to appear in \emph{IEEE Trans.~Software Engineering}.

\bibitem{icse11}
L.~Cordeiro and B.~Fischer.
\newblock Verifying Multi-Threaded Software using {SMT}-based Context-Bounded 
Model Checking.
\newblock {\em ICSE}, pp.\ 331--340, 2011. 

%\bibitem{Z08}
%L.~M. de~Moura and N.~Bj{\o}rner.
%\newblock Z3: An efficient {SMT} solver.
%\newblock {\em TACAS}, {\em LNCS} 4963, pp. 337--340, 2008.

\bibitem{sefm11}
J.~Morse, L.~Cordeiro, D.~Nicole, and B.~Fischer.
\newblock Context-Bounded Model Checking of LTL Properties for ANSI-C Software.
\newblock {\em SEFM}, {\em LNCS} 7041, pp.\ 302--317, 2011.

%\bibitem{wtr}
%R.~Barreto, L.~Cordeiro, and B.~Fischer.
%\newblock Verifying Embedded C Software with Timing Constraints using an
%Untimed Bounded Model Checker
%\newblock {\em Proc.\ SBESC Workshop on Real-Time Systems}, to appear, 2011.

%\bibitem{Godefroid95}
%Patrice Godefroid.
%\newblock {\em Partial-order Methods for the Verification of Concurrent
%  Systems: An Approach to the State-explosion Problem}.
%\newblock University of Liege, PhD thesis, 1995.

\end{thebibliography}}

\end{document}

