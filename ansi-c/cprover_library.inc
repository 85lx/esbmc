{
{ "c::isalnum",
  "\n"
  "inline int isalnum(int c)\n"
  "{ return (c>='a' && c<='z') || (c>='A' && c<='Z') || (c>='0' && c<='9'); }\n"
  "\n"
},
{ "c::isalpha",
  "\n"
  "inline int isalpha(int c)\n"
  "{ return (c>='a' && c<='z') || (c>='A' && c<='Z'); }\n"
  "\n"
},
{ "c::isblank",
  "\n"
  "inline int isblank(int c)\n"
  "{ return c==' ' || c=='\\t'; }\n"
  "\n"
},
{ "c::iscntrl",
  "\n"
  "inline int iscntrl(int c)\n"
  "{ return (c>=0 && c<='\\037') || c=='\\177'; }\n"
  "\n"
},
{ "c::isdigit",
  "\n"
  "inline int isdigit(int c)\n"
  "{ return c>='0' && c<='9'; }\n"
  "\n"
},
{ "c::isgraph",
  "\n"
  "inline int isgraph(int c)\n"
  "{ return c>='!' && c<='~'; }\n"
  "\n"
},
{ "c::islower",
  "\n"
  "inline int islower(int c)\n"
  "{ return c>='a' && c<='z'; }\n"
  "\n"
},
{ "c::isprint",
  "\n"
  "inline int isprint(int c)\n"
  "{ return c>=' ' && c<='~'; }\n"
  "\n"
},
{ "c::ispunct",
  "\n"
  "inline int ispunct(int c)\n"
  "{ return c=='!' ||\n"
  "         c=='\"' ||\n"
  "         c=='#' ||\n"
  "         c=='$' ||\n"
  "         c=='%' ||\n"
  "         c=='&' ||\n"
  "         c=='\\'' ||\n"
  "         c=='(' ||\n"
  "         c==')' ||\n"
  "         c=='*' ||\n"
  "         c=='+' ||\n"
  "         c==',' ||\n"
  "         c=='-' ||\n"
  "         c=='.' ||\n"
  "         c=='/' ||\n"
  "         c==':' ||\n"
  "         c==';' ||\n"
  "         c=='<' ||\n"
  "         c=='=' ||\n"
  "         c=='>' ||\n"
  "         c=='?' ||\n"
  "         c=='@' ||\n"
  "         c=='[' ||\n"
  "         c=='\\\\' ||\n"
  "         c==']' ||\n"
  "         c=='^' ||\n"
  "         c=='_' ||\n"
  "         c=='`' ||\n"
  "         c=='{' ||\n"
  "         c=='|' ||\n"
  "         c=='}' ||\n"
  "         c=='~'; }\n"
  "\n"
},
{ "c::isspace",
  "\n"
  "inline int isspace(int c)\n"
  "{ return c=='\\t' ||\n"
  "         c=='\\n' ||\n"
  "         c=='\\v' ||\n"
  "         c=='\\f' ||\n"
  "         c=='\\r' ||\n"
  "         c==' '; }\n"
  "\n"
},
{ "c::isupper",
  "\n"
  "inline int isupper(int c)\n"
  "{ return c>='A' && c<='Z'; }\n"
  "\n"
},
{ "c::isxdigit",
  "\n"
  "inline int isxdigit(int c)\n"
  "{ return (c>='A' && c<='F') || (c>='a' && c<='f') || (c>='0' && c<='9'); }\n"
  "\n"
},
{ "c::tolower",
  "\n"
  "inline int tolower(int c)\n"
  "{ return (c>='A' && c<='Z')?c+('a'-'A'):c; }\n"
  "\n"
},
{ "c::toupper",
  "\n"
  "inline int toupper(int c)\n"
  "{ return (c>='a' && c<='z')?c-('a'-'A'):c; }\n"
  "\n"
},
{ "c::getopt",
  "\n"
  "extern char *optarg;\n"
  "\n"
  "inline int getopt(int argc, char * const argv[],\n"
  "                  const char *optstring)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  unsigned result_index;\n"
  "  __ESBMC_assume(result_index<argc);\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(optstring),\n"
  "    \"getopt zero-termination of 3rd argument\");\n"
  "  #endif\n"
  "  optarg = argv[result_index];\n"
  "}\n"
  "\n"
},
{ "c::putchar",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int putchar(int c)\n"
  "{\n"
  "  _Bool error;\n"
  "  __ESBMC_HIDE: printf(\"%c\", c);\n"
  "  return (error?-1:c);\n"
  "}\n"
  "\n"
},
{ "c::puts",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int puts(const char *s)\n"
  "{\n"
  "  _Bool error;\n"
  "  int ret;\n"
  "  __ESBMC_HIDE: printf(\"%s\\n\", s);\n"
  "  if(error) ret=-1; else __ESBMC_assume(ret>=0);\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "c::fopen",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __ESBMC_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __ESBMC_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline FILE *fopen(const char *filename, const char *m)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  FILE *f=malloc(sizeof(FILE));\n"
  "\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(f), \"fopen zero-termination of 1st argument\");\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(m), \"fopen zero-termination of 2nd argument\");\n"
  "  #endif\n"
  "\n"
  "  return f;\n"
  "}\n"
  "\n"
},
{ "c::fclose",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fclose(FILE *stream)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  int return_value;\n"
  "  free(stream);\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "c::fdopen",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __ESBMC_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __ESBMC_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline FILE *fdopen(int handle, const char *m)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  FILE *f=malloc(sizeof(FILE));\n"
  "\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(m),\n"
  "    \"fdopen zero-termination of 2nd argument\");\n"
  "  #endif\n"
  "\n"
  "  return f;\n"
  "}\n"
  "\n"
},
{ "c::fgets",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline char *fgets(char *str, int size, FILE *stream)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  _Bool error;\n"
  "\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  int resulting_size;\n"
  "  __ESBMC_assert(__ESBMC_buffer_size(str)>=size, \"buffer-overflow in fgets\");\n"
  "  if(size>0)\n"
  "  {\n"
  "    __ESBMC_assume(resulting_size<size);\n"
  "    __ESBMC_is_zero_string(str)=!error;\n"
  "    __ESBMC_zero_string_length(str)=resulting_size;\n"
  "  }\n"
  "  #endif\n"
  "\n"
  "  return error?0:str;\n"
  "}\n"
  "\n"
},
{ "c::fread",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline size_t fread(\n"
  "  void *ptr,\n"
  "  size_t size,\n"
  "  size_t nitems,\n"
  "  FILE *stream)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  size_t nread;\n"
  "  size_t bytes=nread*size;\n"
  "  size_t i;\n"
  "  __ESBMC_assume(nread<=nitems);\n"
  "\n"
  "  for(i=0; i<bytes; i++)\n"
  "  {\n"
  "    char nondet_char;\n"
  "    ((char *)ptr)[i]=nondet_char;\n"
  "  }\n"
  "\n"
  "  return nread;\n"
  "}\n"
  "\n"
},
{ "c::feof",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int feof(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  int return_value;\n"
  "  *stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "c::ferror",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int ferror(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  int return_value;\n"
  "  *stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "c::fileno",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fileno(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  int return_value;\n"
  "  *stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "c::fputs",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fputs(const char *s, FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  int return_value;\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(s), \"fputs zero-termination of 1st argument\");\n"
  "  #endif\n"
  "  *stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "c::fflush",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fflush(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  int return_value;\n"
  "  *stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "c::fpurge",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int fpurge(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  int return_value;\n"
  "  *stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "c::read",
  "\n"
  "#ifndef __ESBMC_UNISTD_H_INCLUDED\n"
  "#include <unistd.h>\n"
  "#define __ESBMC_UNISTD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline ssize_t read(int fildes, void *buf, size_t nbyte)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  ssize_t nread;\n"
  "  size_t i;\n"
  "  __ESBMC_assume(nread<=nbyte);\n"
  "\n"
  "  for(i=0; i<nbyte; i++)\n"
  "  {\n"
  "    char nondet_char;\n"
  "    ((char *)buf)[i]=nondet_char;\n"
  "  }\n"
  "\n"
  "  return nread;\n"
  "}\n"
  "\n"
},
{ "c::fgetc",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fgetc(FILE *stream)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  int return_value;\n"
  "  *stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "c::getc",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int getc(FILE *stream)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  int return_value;\n"
  "  *stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "c::getchar",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int getchar()\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  int return_value;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "c::getw",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int getw(FILE *stream)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  int return_value;\n"
  "  *stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "c::fseek",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fseek(FILE *stream, long offset, int whence)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  int return_value;\n"
  "  *stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "c::ftell",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline long ftell(FILE *stream)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  int return_value;\n"
  "  *stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "c::rewind",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline void rewind(FILE *stream)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  *stream;\n"
  "}\n"
  "\n"
},
{ "c::fwrite",
  "\n"
  "#ifndef __ESBMC_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __ESBMC_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "size_t fwrite(\n"
  "  const void *ptr,\n"
  "  size_t size,\n"
  "  size_t nitems,\n"
  "  FILE *stream)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  size_t nwrite;\n"
  "  __ESBMC_assume(nwrite<=nitems);\n"
  "  return nwrite;\n"
  "}\n"
  "\n"
},
{ "c::abs",
  "\n"
  "inline int abs(int i) { return __ESBMC_abs(i); }\n"
  "\n"
},
{ "c::labs",
  "\n"
  "inline long int labs(long int i) { return __ESBMC_labs(i); }\n"
  "\n"
},
{ "c::fabs",
  "\n"
  "inline double fabs(double d) { return __ESBMC_fabs(d); }\n"
  "\n"
},
{ "c::fabsl",
  "\n"
  "inline long double fabsl(long double d) { return __ESBMC_fabsl(d); }\n"
  "\n"
},
{ "c::fabsf",
  "\n"
  "inline float fabsf(float f) { return __ESBMC_fabsf(f); }\n"
  "\n"
},
{ "c::isfinite",
  "\n"
  "int isfinite(double d) { return __ESBMC_isfinite(d); }\n"
  "\n"
},
{ "c::isinf",
  "\n"
  "inline int isinf(double d) { return __ESBMC_isinf(d); }\n"
  "\n"
},
{ "c::isnan",
  "\n"
  "inline int isnan(double d) { return __ESBMC_isnan(d); }\n"
  "\n"
},
{ "c::isnormal",
  "\n"
  "int isnormal(double d) { return __ESBMC_isnormal(d); }\n"
  "\n"
},
{ "c::signbit",
  "\n"
  "inline int signbit(double d) { return __ESBMC_sign(d); }\n"
  "\n"
},
{ "c::__fpclassifyd",
  "\n"
  "#ifndef __ESBMC_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __ESBMC_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int __fpclassifyd(double d) {\n"
  "  if(__ESBMC_isnan(d)) return FP_NAN;\n"
  "  if(__ESBMC_isinf(d)) return FP_INFINITE;\n"
  "  if(d==0) return FP_ZERO;\n"
  "  if(__ESBMC_isnormal(d)) return FP_NORMAL;\n"
  "  return FP_SUBNORMAL;\n"
  "}\n"
  "\n"
},
{ "c::__fpclassifyf",
  "\n"
  "#ifndef __ESBMC_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __ESBMC_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int __fpclassifyf(float f) {\n"
  "  if(__ESBMC_isnan(f)) return FP_NAN;\n"
  "  if(__ESBMC_isinf(f)) return FP_INFINITE;\n"
  "  if(f==0) return FP_ZERO;\n"
  "  if(__ESBMC_isnormal(f)) return FP_NORMAL;\n"
  "  return FP_SUBNORMAL;\n"
  "}\n"
  "\n"
},
{ "c::__fpclassify",
  "\n"
  "#ifndef __ESBMC_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __ESBMC_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int __fpclassify(long double d) {\n"
  "  if(__ESBMC_isnan(d)) return FP_NAN;\n"
  "  if(__ESBMC_isinf(d)) return FP_INFINITE;\n"
  "  if(d==0) return FP_ZERO;\n"
  "  if(__ESBMC_isnormal(d)) return FP_NORMAL;\n"
  "  return FP_SUBNORMAL;\n"
  "}\n"
  "\n"
},
{ "c::fegetround",
  "\n"
  "int fegetround() { return __ESBMC_rounding_mode; }\n"
  "\n"
},
{ "c::fesetround",
  "\n"
  "int fesetround(int __rounding_direction) {\n"
  "  __ESBMC_rounding_mode=__rounding_direction;\n"
  "}\n"
},
{ "c::pthread_mutex_init",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_mutex_init(\n"
  "  pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  __ESBMC_mutex_lock_field(*mutex)=0;\n"
  "  __ESBMC_mutex_count_field(*mutex)=0;\n"
  "  __ESBMC_mutex_owner_field(*mutex)=0;\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "c::pthread_mutex_lock",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_mutex_lock(pthread_mutex_t *mutex)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  static _Bool unlocked = 1;\n"
  "  static _Bool deadlock_mutex=0;\n"
  "  extern int trds_in_run, trds_count, count_lock=0;\n"
  "\n"
  "#ifdef __ESBMC_DEADLOCK_DETECTION\n"
  "  __ESBMC_yield();\n"
  "  __ESBMC_atomic_begin();\n"
  "  unlocked = (__ESBMC_mutex_lock_field(*mutex)==0);\n"
  "\n"
  "  if (unlocked)\n"
  "    __ESBMC_mutex_lock_field(*mutex)=1;\n"
  "  else\n"
  "    count_lock++;\n"
  "  __ESBMC_atomic_end();\n"
  "\n"
  "  if (__ESBMC_mutex_lock_field(*mutex)==0)\n"
  "	count_lock--;\n"
  "\n"
  "  if (!unlocked)\n"
  "  {\n"
  "	deadlock_mutex = (count_lock == trds_in_run);\n"
  "	__ESBMC_assert(!deadlock_mutex,\"deadlock detected with mutex lock\");\n"
  "    __ESBMC_assume(deadlock_mutex);\n"
  "  }\n"
  "#endif\n"
  "\n"
  "#ifndef __ESBMC_DEADLOCK_DETECTION\n"
  "  __ESBMC_yield();\n"
  "  __ESBMC_assume(!__ESBMC_mutex_lock_field(*mutex));\n"
  "  __ESBMC_atomic_begin();\n"
  "  __ESBMC_mutex_lock_field(*mutex)=1;\n"
  "  __ESBMC_atomic_end();\n"
  "#endif\n"
  "\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "c::pthread_mutex_trylock",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_mutex_trylock(pthread_mutex_t *mutex)\n"
  "{\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "c::pthread_mutex_unlock",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_mutex_unlock(pthread_mutex_t *mutex)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  __ESBMC_atomic_begin();\n"
  "#ifndef __ESBMC_DEADLOCK_DETECTION\n"
  "#ifdef __ESBMC_LOCK_DETECTION\n"
  "  __ESBMC_assert(__ESBMC_mutex_lock_field(*mutex), \"must hold lock upon unlock\");\n"
  "#endif\n"
  "#endif\n"
  "  __ESBMC_mutex_lock_field(*mutex)=0;\n"
  "  __ESBMC_atomic_end();\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "c::pthread_mutex_destroy",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_mutex_destroy(pthread_mutex_t *mutex)\n"
  "{ }\n"
  "\n"
},
{ "c::pthread_exit",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void pthread_exit(void *value_ptr)\n"
  "{ __ESBMC_assume(0); }\n"
  "\n"
},
{ "c::pthread_rwlock_destroy",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_destroy(pthread_rwlock_t *lock)\n"
  "{ }\n"
  "\n"
},
{ "c::pthread_rwlock_init",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_init(pthread_rwlock_t *lock,\n"
  "  const pthread_rwlockattr_t *attr)\n"
  "{ __ESBMC_HIDE: __ESBMC_rwlock_field(*lock)=0; }\n"
  "\n"
},
{ "c::pthread_rwlock_rdlock",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_rdlock(pthread_rwlock_t *lock)\n"
  "{ /* TODO */ }\n"
  "\n"
},
{ "c::pthread_rwlock_tryrdlock",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_tryrdlock(pthread_rwlock_t *lock)\n"
  "{ /* TODO */ }\n"
  "\n"
},
{ "c::pthread_rwlock_trywrlock",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_trywrlock(pthread_rwlock_t *lock)\n"
  "{ __ESBMC_HIDE:\n"
  "  __ESBMC_atomic_begin();\n"
  "  if(__ESBMC_rwlock_field(*lock)) { __ESBMC_atomic_end(); return 1; }\n"
  "  __ESBMC_rwlock_field(*lock)=1;\n"
  "  __ESBMC_atomic_end();\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "c::pthread_rwlock_unlock",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_unlock(pthread_rwlock_t *lock)\n"
  "{ __ESBMC_HIDE: __ESBMC_rwlock_field(*lock)=0; }\n"
  "\n"
},
{ "c::pthread_rwlock_wrlock",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_wrlock(pthread_rwlock_t *lock)\n"
  "{ __ESBMC_HIDE:\n"
  "  __ESBMC_atomic_begin();\n"
  "  __ESBMC_assume(!__ESBMC_rwlock_field(*lock));\n"
  "  __ESBMC_rwlock_field(*lock)=1;\n"
  "  __ESBMC_atomic_end();\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "c::pthread_join",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "#if 0\n"
  "inline int pthread_join(pthread_t __th, void **__thread_return)\n"
  "{\n"
  "#if 0\n"
  "	extern unsigned int trds_in_join=0;\n"
  "    __ESBMC_atomic_begin();\n"
  "    trds_in_join++;\n"
  "    __ESBMC_atomic_end();\n"
  "    __ESBMC_yield();\n"
  "    __ESBMC_atomic_begin();\n"
  "//    __ESBMC_assume((trds_status & (__th << 1)) == 0);\n"
  "    trds_in_join--;\n"
  "    __ESBMC_atomic_end();\n"
  "    return 0;\n"
  "#endif\n"
  "  /* TODO */\n"
  "  return 0; // we never fail\n"
  "}\n"
  "#endif\n"
  "#if 0\n"
},
{ "c::pthread_cond_broadcast",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_cond_broadcast(pthread_cond_t *cond)\n"
  "{\n"
  "  //__ESBMC_HIDE:\n"
  "  //printf(\"broadcast_counter: %d\", __ESBMC_cond_broadcast_seq_field(*cond));\n"
  "  //__ESBMC_cond_broadcast_seq_field(*cond)=1;\n"
  "  //printf(\"broadcast_counter: %d\", __ESBMC_cond_broadcast_seq_field(*cond));\n"
  "  __ESBMC_cond_broadcast_seq_field(*cond)=1;\n"
  "  __ESBMC_assert(__ESBMC_cond_broadcast_seq_field(*cond),\"__ESBMC_cond_broadcast_seq_field(*cond)\");\n"
  "  return 0; // we never fail\n"
  "}\n"
  "#endif\n"
},
{ "c::pthread_cond_init",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_cond_init(\n"
  "  pthread_cond_t *cond,\n"
  "  __const pthread_condattr_t *cond_attr)\n"
  "{\n"
  "  __ESBMC_atomic_begin();\n"
  "  __ESBMC_cond_lock_field(*cond)=0;\n"
  "  __ESBMC_cond_broadcast_seq_field(*cond)=0;\n"
  "  __ESBMC_atomic_end();\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "c::pthread_cond_destroy",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_cond_destroy(pthread_cond_t *__cond)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  __ESBMC_cond_lock_field(*__cond)=0;\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "c::pthread_cond_signal",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "extern inline int pthread_cond_signal(pthread_cond_t *__cond)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  __ESBMC_cond_lock_field(*__cond)=0;\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "c::pthread_cond_wait",
  "\n"
  "#ifndef __ESBMC_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __ESBMC_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  extern int trds_in_run, trds_count;\n"
  "  extern int count_wait=0;\n"
  "  extern static _Bool deadlock_wait=0;\n"
  "  __ESBMC_atomic_begin();\n"
  "  __ESBMC_cond_lock_field(*cond)=1;\n"
  "#ifndef __ESBMC_DEADLOCK_DETECTION\n"
  "#ifdef __ESBMC_LOCK_DETECTION\n"
  "  __ESBMC_assert(__ESBMC_mutex_lock_field(*mutex),\"pthread_cond_wait must hold lock upon unlock\");\n"
  "#endif\n"
  "#endif\n"
  "  __ESBMC_mutex_lock_field(*mutex)=0;\n"
  "  ++count_wait;\n"
  "  __ESBMC_atomic_end();\n"
  "\n"
  "  __ESBMC_atomic_begin();\n"
  "#ifndef __ESBMC_DEADLOCK_DETECTION\n"
  "#ifdef __ESBMC_LOCK_DETECTION\n"
  "  deadlock_wait = (count_wait == trds_in_run);\n"
  "  __ESBMC_assert(!deadlock_wait,\"deadlock detected with pthread_cond_wait\");\n"
  "#endif\n"
  "#endif\n"
  "  __ESBMC_assume(/*deadlock_wait ||*/ __ESBMC_cond_lock_field(*cond)==0);\n"
  "  --count_wait;\n"
  "  __ESBMC_atomic_end();\n"
  "  __ESBMC_mutex_lock_field(*mutex)=1;\n"
  "\n"
  "  return 0; // we never fail\n"
  "}\n"
},
{ "c::exit",
  "\n"
  "#undef exit\n"
  "\n"
  "inline void exit(int status)\n"
  "{\n"
  "  __ESBMC_assume(0);\n"
  "}\n"
  "\n"
},
{ "c::abort",
  "\n"
  "#undef abort\n"
  "\n"
  "inline void abort(void)\n"
  "{\n"
  "  __ESBMC_assume(0);\n"
  "}\n"
  "\n"
},
{ "c::calloc",
  "\n"
  "#ifndef __ESBMC_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __ESBMC_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef calloc\n"
  "\n"
  "inline void *calloc(size_t nmemb, size_t size)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  size_t total_size=nmemb*size;\n"
  "  void *res = malloc(total_size);\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_is_zero_string(res);\n"
  "  __ESBMC_zero_string_length(res)=0;\n"
  "  //for(int i=0; i<nmemb*size; i++) res[i]=0;\n"
  "  #else\n"
  "  // there should be memset here\n"
  "  //char *p=res;\n"
  "  //for(int i=0; i<total_size; i++) p[i]=0;\n"
  "  #endif\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "c::atoi",
  "\n"
  "#ifndef __ESBMC_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __ESBMC_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef atoi\n"
  "\n"
  "inline int atoi(const char *nptr)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  int res;\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(nptr),\n"
  "    \"zero-termination of argument of atoi\");\n"
  "  #endif\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "c::atol",
  "\n"
  "#ifndef __ESBMC_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __ESBMC_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef atol\n"
  "\n"
  "inline long atol(const char *nptr)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  long res;\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(nptr),\n"
  "    \"zero-termination of argument of atol\");\n"
  "  #endif\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "c::getenv",
  "\n"
  "#undef getenv\n"
  "\n"
  "inline char *getenv(const char *name)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(name),\n"
  "    \"zero-termination of argument of getenv\");\n"
  "  #endif\n"
  "\n"
  "  _Bool found;\n"
  "  if(!found) return 0;\n"
  "\n"
  "  char *buffer;\n"
  "  size_t buf_size;\n"
  "\n"
  "  __ESBMC_assume(buf_size>=1);\n"
  "  buffer=(char *)malloc(buf_size);\n"
  "  buffer[buf_size-1]=0;\n"
  "  return buffer;\n"
  "}\n"
  "\n"
  "#if 0\n"
},
{ "c::calloc",
  "\n"
  "#ifndef __ESBMC_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __ESBMC_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline void* calloc(size_t nmemb, size_t size)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  void *res = malloc(nmemb*size);\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_is_zero_string(res);\n"
  "  __ESBMC_zero_string_length(res)=0;\n"
  "  //for(int i=0; i<nmemb*size; i++) res[i]=0;\n"
  "  #else\n"
  "  char *p=res;\n"
  "  for(int i=0; i<nmemb*size; i++) p[i]=0;\n"
  "  #endif\n"
  "  return res;\n"
  "}\n"
  "#endif\n"
},
{ "c::strcpy",
  "\n"
  "#ifndef __ESBMC_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __ESBMC_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline char *strcpy(char *dst, const char *src)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(src), \"strcpy zero-termination of 2nd argument\");\n"
  "  __ESBMC_assert(__ESBMC_buffer_size(dst)>__ESBMC_zero_string_length(src), \"strcpy buffer overflow\");\n"
  "  dst[__ESBMC_zero_string_length(src)]=0;\n"
  "  __ESBMC_is_zero_string(dst)=1;\n"
  "  __ESBMC_zero_string_length(dst)=__ESBMC_zero_string_length(src);\n"
  "  #else\n"
  "  size_t i;\n"
  "  for(i=0; src[i]!=0; i++)\n"
  "    dst[i]=src[i];\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "c::strncpy",
  "\n"
  "#ifndef __ESBMC_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __ESBMC_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline char *strncpy(char *dst, const char *src, size_t n)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(src), \"strncpy zero-termination of 2nd argument\");\n"
  "  __ESBMC_assert(__ESBMC_buffer_size(dst)>=n, \"strncpy buffer overflow\");\n"
  "  __ESBMC_is_zero_string(dst)=__ESBMC_zero_string_length(src)<n;\n"
  "  __ESBMC_zero_string_length(dst)=__ESBMC_zero_string_length(src);\n"
  "  #else\n"
  "  size_t i=0;\n"
  "  for( ; i<n && src[i]!=0; i++)\n"
  "    dst[i]=src[i];\n"
  "  for( ; i<n ; i++)\n"
  "    dst[i]=0;\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "c::strcat",
  "\n"
  "#ifndef __ESBMC_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __ESBMC_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline char *strcat(char *dst, const char *src)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  size_t new_size;\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(dst), \"strcat zero-termination of 1st argument\");\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(src), \"strcat zero-termination of 2nd argument\");\n"
  "  new_size=__ESBMC_zero_string_length(dst)+__ESBMC_zero_string_length(src);\n"
  "  printf(\"new_size: %d\", new_size);\n"
  "  __ESBMC_assert(__ESBMC_buffer_size(dst)>=new_size,\n"
  "                   \"strcat buffer overflow\");\n"
  "  size_t old_size=__ESBMC_zero_string_length(dst);\n"
  "  //\"  for(size_t i=0; i<__ESBMC_zero_string_length(src); i++)\n"
  "  //\"    dst[old_size+i];\n"
  "  dst[new_size - 1]=0;\n"
  "  __ESBMC_is_zero_string(dst)=1;\n"
  "  __ESBMC_zero_string_length(dst)=new_size;\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "c::strncat",
  "\n"
  "#ifndef __ESBMC_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __ESBMC_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline char *strncat(char *dst, const char *src, size_t n)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  size_t additional, new_size;\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(dst), \"strncat zero-termination of 1st argument\");\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(src) || __ESBMC_buffer_size(src)>=n, \"strncat zero-termination of 2nd argument\");\n"
  "  additional=(n<__ESBMC_zero_string_length(src))?n:__ESBMC_zero_string_length(src);\n"
  "  new_size=__ESBMC_is_zero_string(dst)+additional;\n"
  "  __ESBMC_assert(__ESBMC_buffer_size(dst)>new_size,\n"
  "                   \"strncat buffer overflow\");\n"
  "  size_t dest_len=__ESBMC_zero_string_length(dst);\n"
  "  size_t i;\n"
  "  for (i = 0 ; i < n && i<__ESBMC_zero_string_length(src) ; i++)\n"
  "    dst[dest_len + i] = src[i];\n"
  "  dst[dest_len + i] = 0;\n"
  "  __ESBMC_is_zero_string(dst)=1;\n"
  "  __ESBMC_zero_string_length(dst)=new_size;\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "c::strcmp",
  "\n"
  "#ifndef __ESBMC_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __ESBMC_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int strcmp(const char *s1, const char *s2)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  int retval;\n"
  "  if(s1!=0 && s1==s2) return 0;\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(s1), \"strcmp zero-termination of 1st argument\");\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(s2), \"strcmp zero-termination of 2nd argument\");\n"
  "  if(__ESBMC_zero_string_length(s1) != __ESBMC_zero_string_length(s1)) __ESBMC_assume(retval!=0);\n"
  "  #endif\n"
  "  return retval;\n"
  "}\n"
  "\n"
},
{ "c::strncmp",
  "\n"
  "#ifndef __ESBMC_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __ESBMC_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int strncmp(const char *s1, const char *s2, size_t n)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  if(s1!=0 && s1==s2) return 0;\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(s1) || __ESBMC_buffer_size(s1)>=n, \"strncmp zero-termination of 1st argument\");\n"
  "  __ESBMC_assert(__ESBMC_is_zero_string(s1) || __ESBMC_buffer_size(s2)>=n, \"strncmp zero-termination of 2nd argument\");\n"
  "  #else\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "c::strlen",
  "\n"
  "#ifndef __ESBMC_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __ESBMC_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline size_t strlen(const char *s)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  //__ESBMC_assert(__ESBMC_is_zero_string(s), \"strlen zero-termination\");\n"
  "  return __ESBMC_zero_string_length(s);\n"
  "  #else\n"
  "  size_t len=0;\n"
  "  while(s[len]!=0) len++;\n"
  "  return len;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "c::strdup",
  "\n"
  "#ifndef __ESBMC_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __ESBMC_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __ESBMC_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __ESBMC_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline char *strdup(const char *str)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  size_t bufsz;\n"
  "  bufsz=(strlen(str)+1)*sizeof(char);\n"
  "  char *cpy=malloc(bufsz);\n"
  "  if(cpy==((void *)0)) return 0;\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assume(__ESBMC_buffer_size(cpy)==bufsz);\n"
  "  #endif\n"
  "  cpy=strcpy(cpy, str);\n"
  "  return cpy;\n"
  "}\n"
  "\n"
},
{ "c::memcpy",
  "\n"
  "#ifndef __ESBMC_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __ESBMC_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline void *memcpy(void *dst, const void *src, size_t n)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  //__ESBMC_assert(__ESBMC_buffer_size(src)>=n, \"memcpy buffer overflow\");\n"
  "  //__ESBMC_assert(__ESBMC_buffer_size(dst)>=n, \"memcpy buffer overflow\");\n"
  "  //  for(size_t i=0; i<n ; i++) dst[i]=src[i];\n"
  "  if(__ESBMC_is_zero_string(src) &&\n"
  "     n > __ESBMC_zero_string_length(src))\n"
  "  {\n"
  "    __ESBMC_is_zero_string(dst)=1;\n"
  "    __ESBMC_zero_string_length(dst)=__ESBMC_zero_string_length(src);\n"
  "  }\n"
  "  else if(!(__ESBMC_is_zero_string(dst) &&\n"
  "            n <= __ESBMC_zero_string_length(dst)))\n"
  "    __ESBMC_is_zero_string(dst)=0;\n"
  "  #else\n"
  "  for(size_t i=0; i<n ; i++) dst[i]=src[i];\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "c::memset",
  "\n"
  "#ifndef __ESBMC_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __ESBMC_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline void *memset(void *s, int c, size_t n)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  char *sp=s;\n"
  "  for(size_t i=0; i<n ; i++) {sp[i]=c;}\n"
  "#if 0\n"
  "  __ESBMC_assert(__ESBMC_buffer_size(s) * sizeof(s) >= n, \"memset buffer overflow\");\n"
  "  //for(size_t i=0; i<n ; i++) s[i]=c;\n"
  "\n"
  "  if(__ESBMC_is_zero_string(s) &&\n"
  "     n > __ESBMC_zero_string_length(s))\n"
  "  {\n"
  "    __ESBMC_is_zero_string(s)=1;\n"
  "  }\n"
  "  else if(c==0)\n"
  "  {\n"
  "    __ESBMC_is_zero_string(s)=1;\n"
  "    __ESBMC_zero_string_length(s)=0;\n"
  "  }\n"
  "  else\n"
  "    __ESBMC_is_zero_string(s)=0;\n"
  "#endif\n"
  "  #else\n"
  "  char *sp=s;\n"
  "  for(size_t i=0; i<n ; i++) sp[i]=c;\n"
  "  #endif\n"
  "  return s;\n"
  "}\n"
  "\n"
},
{ "c::memmove",
  "\n"
  "#ifndef __ESBMC_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __ESBMC_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline void *memmove(void *dest, const void *src, size_t n)\n"
  "{\n"
  "  __ESBMC_HIDE:\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assert(__ESBMC_buffer_size(src)>=n, \"memmove buffer overflow\");\n"
  "  // dst = src (with overlap allowed)\n"
  "  if(__ESBMC_is_zero_string(src) &&\n"
  "     n > __ESBMC_zero_string_length(src))\n"
  "  {\n"
  "    __ESBMC_is_zero_string(src)=1;\n"
  "    __ESBMC_zero_string_length(dest)=__ESBMC_zero_string_length(src);\n"
  "  }\n"
  "  else\n"
  "    __ESBMC_is_zero_string(dest)=0;\n"
  "  #else\n"
  "  if (dest-src >= n)\n"
  "  {\n"
  "    for(size_t i=0; i<n ; i++) dest[i]=src[i];\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    for(size_t i=n; i>0 ; i--) dest[i-1]=src[i-1];\n"
  "  }\n"
  "  #endif\n"
  "  return dest;\n"
  "}\n"
  "\n"
},
{ "c::memcmp",
  "\n"
  "#ifndef __ESBMC_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __ESBMC_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int memcmp(const void *s1, const void *s2, size_t n)\n"
  "{\n"
  "  __ESBMC_HIDE:;\n"
  "  int res;\n"
  "  #ifdef __ESBMC_STRING_ABSTRACTION\n"
  "  __ESBMC_assert(__ESBMC_buffer_size(s1)>=n, \"memcmp buffer overflow of 1st argument\");\n"
  "  __ESBMC_assert(__ESBMC_buffer_size(s2)>=n, \"memcmp buffer overflow of 2nd argument\");\n"
  "  #else\n"
  "  const unsigned char *sc1=s1, *sc2=s2;\n"
  "  for(; n!=0; n--)\n"
  "  {\n"
  "    res = (s1++) - (s2++);\n"
  "    if (res != 0)\n"
  "      return res;\n"
  "  }\n"
  "  #endif\n"
  "  return res;\n"
  "}\n"
},
{ "c::time",
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef time\n"
  "\n"
  "time_t time(time_t *tloc)\n"
  "{\n"
  "  time_t res;\n"
  "  if(!tloc) *tloc=res;\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ 0, 0 }
};
