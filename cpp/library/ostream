#ifndef STL_OSTREAM
#define STL_OSTREAM

#include "ios"
#include "definitions.h"
//#include "iomanip"
//#include "cstring"

namespace std
{
struct ostream
{
	typedef int streampos;
	typedef int streamoff;

	ostream();
	explicit ostream (streambuf * sb);
	ostream(int id): id(id){}
	virtual ~ostream();

	int id;
	streamsize width ( ) const;
	streamsize width ( streamsize wide );
	void fill(char c);
	void precision(int p);
	void put(char c);
//	void write(char str[], size_t n);
	ostream& write ( const char* s , streamsize n );
	streampos tellp ( ); //model
	ostream& seekp ( streampos pos ); //model
	ostream& seekp ( streamoff off, ios_base::seekdir dir ); //model
//	ostream& flush ( );
	ios_base::fmtflags flags ( ) const;
	ios_base::fmtflags flags ( ios_base::fmtflags fmtfl );

	struct sentry {
		public:
		  explicit sentry ( ostream& os );
		  ~sentry();
		  operator bool() const;
		private:
		  sentry (const sentry&);             // not defined
		  sentry& operator= (const sentry& ); // not defined
	};

private:
	ostream(const ostream&); // disabled
	ostream& operator=(const ostream&); // disabled
	streamsize _filesize = nondet_uint();
	static ios::streampos _filepos;
};
//ios::streampos ostream::_filepos = 0;

}

namespace esbmc
{
	void esbmc_print_cstr(int o, const char* cstr){}
	void esbmc_print_char(int o, char c){}
	void esbmc_print_int(int o, int i){}
	void esbmc_print_double(int o, double d){}
	void esbmc_print_unsigned(int o, unsigned i){}
	void esbmc_print_bool(int o, bool b){}
	void esbmc_print_long_long(int o, long long i){}
	void esbmc_print_unsigned_long_long(int o, unsigned long long i){}

}

namespace std{



ostream& operator<< (ostream& out, bool val);
ostream& operator<< (ostream& out, short val);
ostream& operator<< (ostream& out, unsigned short val);
ostream& operator<< (ostream& out, int val);
ostream& operator<< (ostream& out, unsigned int val);
//	ostream& operator<< (long val);
//	ostream& operator<< (unsigned long val);
ostream& operator<< (ostream& out, float val);
ostream& operator<< (ostream& out, double val);
//	ostream& operator<< (long double val);
//	ostream& operator<< (const void* val);

ostream& operator<< (ostream& out, streambuf* sb);

ostream& operator<< (ostream& out, ostream& ( *pf )(ostream&));
ostream& operator<< (ostream& out, ios& ( *pf )(ios&));
ostream& operator<< (ostream& out, ios_base& ( *pf )(ios_base&));


ostream& operator<< (ostream& out, char c );
//ostream& operator<< (ostream& out, signed char c );
ostream& operator<< (ostream& out, unsigned char c );

ostream& operator<< (ostream& out, const char* s );
//ostream& operator<< (ostream& out, const signed char* s );
ostream& operator<< (ostream& out, const unsigned char* s );
//ostream& operator<< (ostream& out, smanip sm );

template < typename T >
inline ostream& operator<< ( ostream& o, T i )
{
	return o;
}
//
//inline ostream& operator << (ostream& o, const char*  cstr)  //ok
//{
//	esbmc::esbmc_print_cstr(o.id, cstr);
//	return o;
//}
//
//inline ostream& operator << (ostream& o, char  c)  //ok
//{
//	esbmc::esbmc_print_char(o.id, c);
//	return o;
//}
//
//inline ostream&  operator << (ostream& o, int  i)
//{
//	esbmc::esbmc_print_int(o.id, i);
//	return o;
//}
//
//inline ostream&  operator << (ostream& o, double  d) // Felipe Rodrigues
//{
//	esbmc::esbmc_print_double(o.id, d);
//	return o;
//}
//
//inline ostream& operator << (ostream& o, unsigned  i)
//{
//	esbmc::esbmc_print_unsigned(o.id, i);
//	return o;
//
//}
//inline ostream& operator << (ostream& o, long long  i)
//{
//	esbmc::esbmc_print_long_long(o.id, i);
//	return o;
//}
//
//inline ostream& operator << (ostream& o, unsigned long long  i)
//{
//	esbmc::esbmc_print_unsigned_long_long(o.id, i);
//	return o;
//}
//
//inline ostream& operator << (ostream& o, bool  b)
//{
//	esbmc::esbmc_print_bool(o.id, b);
//	return o;
//}
//
//

}

namespace std
{
	void ostream::fill(char c)
	{
//		setfill(c);
	}

	void ostream::precision(int p)
	{
//		setprecision(p);
	}

	void ostream::put(char c)
	{
	}

	//	void ostream::write(char str[], size_t n)
	ostream& ostream::write ( const char* s , streamsize n )
	{
		_filepos = n;
		return *this;
	}

	ostream& ostream::seekp ( ios::streampos pos ) {
		//__ESBMC_assert (pos<=_filesize, "Invalid stream position");
		_filepos = pos;
		return *this;
	}
	ostream& ostream::seekp ( ios::streamoff off, ios_base::seekdir dir ) {
		if (dir==ios::beg) {_filepos=off;}
		if (dir==ios::cur) {_filepos+=off;}
		if (dir==ios::end) {_filepos=_filesize-off;}
		return *this;
	}
	ios::streampos ostream::tellp ( ) {
		__ESBMC_assert (_filepos>=0, "Invalid stream position");
		return _filepos;
	}
}

namespace std {
	//Output manipulators
	ostream& endl ( ostream& os );
	ostream& ends ( ostream& os );
	ostream& flush ( ostream& os );
}

#endif
