%\documentclass[oribibl,runningheads,a4paper]{llncs}
\documentclass[a4paper]{llncs}
\usepackage{url}
\usepackage{times}
\usepackage{listings}
\usepackage{graphicx,marvosym}

\newcommand{\comment}[1]{}
\newcommand{\citenot}[1]{}
\newcommand{\blurb}[1]{{\texttt{[.. #1..]}}}


\begin{document}

\lstset{language=C,basicstyle=\small}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt}
\lstset{tabsize=2}
\lstset{firstnumber=1}
\lstset{frame=single}
\lstset{
  language={C},
  morekeywords={assert,uchar}
}

%\mainmatter  % start of an individual contribution

\title{SMT-Based Bounded Model Checking of C++ Programs}
%\title{Context-Bounded Symbolic Model Checking with ESBMC 1.17}
%\title{SMT-Based Bounded Model Checking of C++ Programs}
%\subtitle{(Competition Contribution)}
%\titlerunning{}
\comment{
\author{Lucas Cordeiro$^1$ \and
	Jeremy Morse$^2$   \and
	Denis Nicole$^2$   \and
	Bernd Fischer$^2$}
\authorrunning{Lucas Cordeiro, Jeremy Morse, Denis Nicole, Bernd Fischer}
\institute{
  $^1$ Electronic and Information Research Center, %\\
  Federal University of Amazonas, Brazil\\
  %\url{lucascordeiro@ufam.edu.br}
  %\\\smallskip
  $^2$ Electronics and Computer Science, %\\
  University of Southampton, UK\\
  %\url{{jcmm106,dan,bf}@ecs.soton.ac.uk}
  %\url{http://www.ecs.soton.ac.uk}
  \url{esbmc@ecs.soton.ac.uk}
}
}

\maketitle

\begin{abstract}
Bounded Model Checking (BMC) of C++ programs presents greater
complexity than that of C programs due to the features that the language offers, such as
templates, containers, and exception handling. We present ESBMC++, a bounded
model checker for C++ programs, which encodes the verification conditions via
an operational model using different background theories supported 
by an SMT Solver. This operational model is an abstract representation of
the standard C++ library, which conservatively approximates its semantics. Our
experimental results show that our approach can handle a wider range of the C++
constructs than existing C++ model checkers and substantially reduce the verification time.
\end{abstract}

%------------------------------
\section{Introduction}
%------------------------------
%
Bounded Model Checking (BMC) based on Boolean Satisfiability (SAT) solvers
has already been successfully applied to verify software and to discover 
subtle errors in real systems~\cite{handbook09}.\ In an attempt to cope
with growing system complexity, SAT solvers are increasingly
replaced by Satisfiability Modulo Theories (SMT) solvers to prove the generated 
verification conditions (VCs)~\cite{Armando09,Ganai06,Cordeiro12}.\
There have also been attempts to extend BMC to the verification of C++ 
programs~\cite{Blanc07,Florian12}. The main challenge here is to handle large 
programs and support the features that the languages offers, such as templates, 
containers and exception handling.

C++ is widely used, but systems that make use of the C++ language and its functionalities
tend to require a high verification effort since the errors are hard to find. 
C++ verification involves many more challenges than that of plain ANSI-C since 
it provides a wider set of features (e.g., object-oriented
programming), libraries (e.g., specialized input-output), and functionalities 
(e.g., template usage) that would require too much effort to develop from scratch. 
In order to be attractive for mainstream software development, C++ model checkers have 
to exhibit several crucial characteristics (e.g., speed,
accuracy, efficiency, and friendliness).

To tackle this problem, our proposed approach aims to apply Bounded Model Checking (BMC) 
to C++ programs using an operational model of the C++ libraries. This operational model 
is an abstract representation of the standard C++ library, which conservatively approximates 
its semantics. To support this operational mode, we extended our Efficient SMT-Based Bounded
Model Checker (ESBMC) tool~\cite{Cordeiro12} that builds on the front-end of the C Bounded Model 
Checker (CBMC) to support C++ features such as inheritance, polymorphism, templates, and 
exception handling.

In particular, we develop novel approaches to handle excpetions in C++ code that previous approaches
are not able to deal with~\cite{Florian12,PrabhuMBIG11}. Additionally, we focus on the STL sequential 
containers (which have the most popular data structures in Computing Science) operational model, 
its preconditions and simulation features (e.g., how we store the elements values 
of the containers and intern class methods), and how these are used in order to verify real-world 
C++ programs.

%------------------------------
\section{Background}
%------------------------------

ESBMC++ implements BMC for C++ programs using SMT solvers. 
It can process C/C++ code into equivalent GOTO-programs 
(i.e., control-flow graphs). The GOTO-programs can then be 
processed by the symbolic execution engine. ESBMC++ uses CBMC's 
internal parser, which is based on the OpenC++~\cite{OpenCpp12}, 
to process the C/C++ files and to build an abstract syntax tree (AST). 
The typechecker of ESBMC++’s front end annotates this AST with types and 
generates a symbol table. ESBMC++’s IRep class then converts the annotated 
AST into an internal, language-independent format used by the remaining phase 
of the front-end.

ESBMC++ uses two recursive functions that compute the
constraints (i.e., assumptions and variable assignments) and
properties (i.e., safety conditions and user-defined assertions).
In addition, ESBMC++ automatically generates safety
conditions that check for arithmetic overflow and underflow,
array bounds violations, and NULL-pointer dereferences,
in the spirit of Sites’ clean termination~\cite{Sites74}. Both
functions accumulate the control flow predicates to each
program point and use these predicates to guard both the
constraints and the properties so that they properly reflect
the program’s semantics. ESBMC++’s VC generator (VCG) then
derives the VCs from these.

%------------------------------
\section{C++ Operational Model}
%------------------------------

During the verification process, ESBMC++ has to identify all the 
specifications and features of the C++ program to generate the AST. 
The specifications are related to the definitions of the standard C++ 
libraries such as classes, methods, and types while the features 
(e.g., inheritance, template, and exception handling) are treated internally 
in ESBMC++ in different levels (i.e., scan, parser, and type-check).
In this sense, we developed a simplified representation of the C++ libraries 
called C++ Operational Model (COM) to represent the classes, methods, 
and other features.

The development process of the COM can be divided into two phases: \textit{structural} 
and \textit{modeling}. In the structural phase, we built a set of classes with a specific 
hierarchical relationship and the signature of their methods and specific data, 
which resulted in a simplified structure to represent the set of the standard C++ libraries. 
From this structure, we modeled the methods of each class and this modeling is focused 
on the verification of all properties that a specific method includes.

%------------------------------
\subsection{Structure and Model}
%------------------------------

The goal here is to build an operational model of the standard C++ library 
so that ESBMC++ can rely on it to identify the definitions and to verify all 
the properties related to these definitions. This operational model is inserted 
into the verification process at the level of the source code (i.e., both model and 
program are passed as parameters at the beginning of the verification process).
The first step in the construction process of the operational model is the creation 
of a simplified structure, which is similar to the actual structure. Based 
on the documentation of the C++ language~\cite{CppReference12} the set of libraries 
was split, according to their functionalities, into four subsets called C Libraries, 
Input/Output Stream, Standard Template Libraries, and General Libraries. Each library 
presents in a subset is particularly related to the other libraries, not only in its 
functionality but also in its structure due to the fact that many libraries depend on 
definitions of others. From this, we performed an analysis in the respective subsets 
as shown in Figure~\ref{figure:cpp-diagram} in such a way that we could identify dependencies 
between each library and thus develop a simplified structure of each one. In the next sections, 
we describe the structure of the libraries subsets shown in Figure~\ref{figure:cpp-diagram}.
%
\begin{figure*}[ht]
\centering
\includegraphics[scale=0.28]{figures/diagramascpp}
\caption{Representation of the configuration and functional classification of the operational model.}
\label{figure:cpp-diagram}
\end{figure*}

%------------------------------
\subsection{C Libraries}
%------------------------------

The standard C++ libraries also include all the ANSI-C libraries. 
However, for the verification of C++ programs, ESBMC++ 
follows a different path to parse the C++ programs. 
For this reason, we also have to build a representation 
of the ANSI-C libraries in the operational model. We can thus 
define this libraries' set in a simplified structure, which consists 
essentially of macro definitions and functions. From this ANSI-C libraries' set, 
there are libraries that contains only macro definitions (e.g., the \textit{ciso646} library 
defines a spelling set to the logic operators). To build the structure of this 
library, we distingue two kinds of spelling: we define the macro set and operators set. 
For convention, we assume the macro set $M$ as follows: 
%
\begin{eqnarray}
\label{ciso646-macro-set}
\left\{and, and\_eq, bitand, bitor, compl, not, not\_eq, or, or\_eq, xor, xor\_eq\right\} \subset M
\end{eqnarray}

The operator set $O$ is defined as follows:
%
\begin{eqnarray}
\label{ciso646-operator-set}
\left\{
\: \&\&, 
\: \&= \:, 
\: \& \:, 
\: | \:, 
\: \widetilde{} \:, 
\: ! \:, 
\: || \:, 
\: |= \:, 
\:\: \widehat{} \:\:, 
\: \widehat{}= \: 
\right\} \subset O
\end{eqnarray}

Therefore, we define the syntax for these definitions sets as:
%
\begin{equation}
\left( \alpha \in M \wedge \beta \in O \right) \Rightarrow \left(\forall\alpha\right)\left(\exists\beta\right)\left(\alpha\equiv\beta\right)
\label{eq:csi646-definitions}
\end{equation}

Within the ANSI-C libraries set, we can also represent the structure 
of others libraries with functions only. This is case of the \textit{csignal} 
library, which deals with signals that are emitted to a given code. 
We thus define that the operational model of this library can been represented 
by signals that raise functions. For a vector $v$ of size $N$ and 
for a finite signals set $S$ where $\left\{s_{1},\ldots, s_{n}\right\}\:\subset\:S$ 
and $n < N$, the function signal records a certain function in one specific signal such that when 
the raising function is called with the respective signal, the registered function 
is called. Let $f$ be a function, $\varphi$ be a signal, and $\eta$ be a NULL element. 
We can thus model the signal of the \textit{csginal} library as:
%
%
\begin{eqnarray}
\label{c-csignal}
\left(\varphi = s_{1}\right) \vee \ldots \vee \left(\varphi = s_{n}\right) \Rightarrow store\left(v,\varphi,f\right)
\end{eqnarray}

The raise function can be modeled as:  
%
\begin{eqnarray}
\label{r-csignal}
\left(\varphi = s_{1}\right) \vee \ldots \vee \left(\varphi = s_{n}\right) \wedge \left(select\left(v,\varphi\right) \neq \eta\right) \Rightarrow select\left(v,\varphi\right)  
\end{eqnarray}
\\

\begin{figure*}[ht]
\centering
\includegraphics[scale=0.22]{figures/inputoutputdiagram}
\caption{Diagram about hierarchical structure of the Input / Output Stream Libraries.}
\label{figure:cpp-inputoutputdiagram}
\end{figure*}

\subsection{Input / Output Stream Libraries}
%

The libraries group related to flow control of input and output data inside to certain program is represented for the libraries set 
called Input / Output Stream. Aiming to build the operational model of this set, we elaborated a hierarchical structure really similar 
to real that can be observed in Figure \ref{figure:cpp-inputoutputdiagram}.
\\
%to do formalization
\\

%-------------------------------------------
\subsection{Standard Template Libraries}
%-------------------------------------------

This set is subdivided in four categories: Algorithms, Numeric, Containers and Iterators. The algorithm library is the only one that composes 
the Algorithms categories. The operational model of this library is formed by $66$ functions that present a lot of algorithms related to 
manipulation of STL containers, arrays and string objects. The operation of this model can be illustrated by the formalization of the 
functions $find$ and $for\_each$. The find function looking for a certain element within a range and $for\_each$ function applies each 
element of a range in a certain function. For this, we assume that $\eta$ be a NULL element and $I$ represent a range, such that 
$\left\{first, last, n, i\right\}\:\subset\:I$, so that $first$ represent the pointer to beginning of range, $last$ represent the pointer to ending of range, 
$n$ be the number of elements contained between $first$ and $last$, and $i$ be a certain position within the range. Furthermore, by 
virtue of formalization of the $for\_each$ function we assume $f$ be a function and by virtue of formalization of the $find$ function 
we assume that $\alpha$ be a non-deterministic value and $\beta$ be a boolean value that assume $true$ if the element sought is contained 
in the range and $false$ otherwise. We can thus model the $for\_each$ of the algorithm library as:
\\
\begin{equation}
\left(\left(first \wedge last \wedge f\right) \neq \eta\right) \Rightarrow
\bigwedge^{n}_{i=0} \left(\left(store\left(first, i+1, first_{i} + 1\right)\right) \wedge \left(f\left(first_{i}\right)\right)\right)
\label{eq:model-for-each}
\end{equation}

The $find$ function can be modeled as:

\begin{equation}\left(\left(first \wedge last \wedge \alpha\right) \neq \eta\right) \Rightarrow
\bigwedge^{n}_{i=0} \left(\left(store\left(first, i+1, first_{i} + 1\right)\right)\\ \wedge \left(ite\left(first_{i} = \alpha, \beta = 1,  \beta = 0\right)\right)\right)
\label{eq:model-for-each}
\end{equation}

The operational model created to represent the Numeric category is formed by the numeric library and contains 4 algorithms that work 
objectively in the manipulation of numerical sequences. One of the algorithms implemented in this model is called $accumulate$, whose main 
functionality is to accumulate the values belonging a numerical sequence. In order to exemplify the implementation of this model, we assume 
that $\alpha$ be an accumulator.We can thus model the $accumulate$ of the algorithm library as

\begin{equation}
\left(\left(first \wedge last \wedge \alpha\right) \neq \eta\right) \Rightarrow
\bigwedge^{n}_{i=0} \left(\left(store\left(first, i+1, first_{i} + 1\right)\right) \wedge \left(\alpha = \alpha + first_{i}\right)\right)
\label{eq:accumulate}
\end{equation}

%-------------------------------------------
\subsubsection{Structure.}
%-------------------------------------------

In this section, we will focus on the STL sequential 
containers operational model, its preconditions and 
simulation features (e.g., how we store the elements 
values of the containers and intern class methods), 
and how these are used to verify real-world C++ programs.
The structure of the STL containers is based on the 
C++ structure itself, which includes its classes, operators, 
methods, functions, and intern variables. It is split into: 
iterations, capacity, element access, modifiers and unique 
members. As the containers structure differs a little 
between each other, some of their methods will vary too, 
changing its intern model as well. For example, a list container 
does not have a reference operator (i.e., $operator\left[\right]$), and the elements 
are reached only by iterators (list has a dynamic structure, 
unlike deque or vector). Lists also have unique methods, optimized by its 
dynamic structure such as merging, elements sorting, and reverse order.
Vector has also unique methods, related to size and capacity manipulation, 
and it also does not have $push\_front\left(\right)$ 
and $pop\_front\left(\right)$ methods~\cite{CppReference12}.

%-------------------------------------------	
\subsubsection{Model Semantics.}
%-------------------------------------------
	
Let us consider that a container model is composed 
by five types of variables, which are: $I$, $C$, 
$N$, $P$ and $T$. Let $I$ be an iterator that points 
to a position in the container; $C$ be a container itself; 
$N$ be a natural integer number used in the container
such as size, capacity and elements index; $P$ be 
the memory address where $T$ is located; and $T$ be the 
values stored in the container. 
For convention, we assume that 
$\left(c, v, d, l\right) \subset C, \{i, j, n\} 
\subset N$ and $\{it1, it2\} \subset I$. 
	
The containers contain an array of elements $T$ and their 
positions in the memory are represented by pointers $P$.
Therefore, the syntax for the integer expression is:
%
\[\begin{array}{r@{\:\:}c@{\:\:}l}
\\[-5ex]
\mathit{Int}  & ::= & \: \mathit{N} \: | \: \mathit{Z} \: | \: \mathit{C.size} \: | \: \mathit{C.capacity} \: | \\
              &     & \: \mathit{Int} \: ( + \: | \: ? \: | \: * \: | \: ...) \: \mathit{Int}  \: | \\
              &     & \: \textit{It} \: ( + \: | \: - ) \:  \textit{It} 
\end{array}
\]

Where variables included in the containers 
like \emph{size} and \emph{capacity} return 
a integer value as well as the arithmetics 
operations between integer values. 
Similarly, the syntax for iterator 
expressions is:
%
\[\begin{array}{r@{\:\:}c@{\:\:}l}\label{iterator-semantics}
\\[-5ex]
\mathit{It}   & ::= & \: \mathit{I} \: | \: \mathit{It} ( + \: | \: - ) \mathit{It} \: | \: \mathit{C.begin} \: | \: \mathit{C.end} \:  \\
\end{array}
\]

Where $begin$ and $end$ are methods 
that return iterators, which point to the beginning 
and the ending of a container, respectively. We also have 
iterator operations that return iterators as well. 
For $P$ (memory address values), the syntax is as follows:
%	
\[\begin{array}{r@{\:\:}c@{\:\:}l}\label{pointer-semantics}
\\[-5ex]
\mathit{P}  & ::= & \: \mathit{p} \: | \: \mathit{It.pointer} \: | \: \mathit{C.array} \: | \\
            &     & \: \mathit{It.source} \: | \: \mathit{P}  ( \: + \: | \: - \: )  \textit{P} \: \\
\end{array}
\]

Where $pointer$ is a memory address that stores the element 
in the container pointed by the iterator, $array$ is another 
memory address that stores the beginning of the container, 
$source$ is the address that makes the link between the iterator 
and its pointed container (which stores the container $array$ value). 

There is also the pointer return from pointer operations.
The syntax for \emph{T} values is the following: 
%
\[\begin{array}{r@{\:\:}c@{\:\:}l}\label{element-semantics}
\\[-5ex]
\mathit{T}   & ::= & \: \mathit{t} \: | \: \mathit{*It} \: | \: \mathit{*P} \: | \: \mathit{C_n} \:  \\
\end{array}
\]
%
Where $*It$ is the value stored in the position pointed 
by a iterator $It$. Similarly, $*P$ is the value stored 
in the $P$ position of the memory, and $\mathit{C_n}$ is 
an element of a container $C$ in the position $n$.

%-------------------------------
\subsubsection{Model.}
%-------------------------------

To simulate appropriately the containers, our model makes 
use of three variables: a variable $P$ called $array$ that points 
to the first element of the array, a natural value $size$ that stores 
the quantity of elements in the container, and a natural value $capacity$
that stores the total capacity of a container (which is valid only for vectors). 
Note that, as the elements are added in the container (specifically in vectors) 
and the size grows, the capacity also grows at a rate of $2*size$, every time 
the size reaches the capacity value. Similarly, iterators are modeled using 
three variables: a variable $P$ called $ptr$, which contains the memory address 
to the corresponding element $T$ in the container, a variable $N$ called $pos$, 
which contains the index value pointed by the iterator in the container, and a 
variable $P$ called $src$, which contains the memory address to the first 
element $T$ stored in the container. 

The vector container model has the following structure:
$C = \{ array, size, capacity\}$,
where $array$ is a memory address where the elements are stored in the container, 
$size$ is the total number of elements in the container, and $capacity$ 
is the total capacity of the vector, which is simulated internally in the model.
The main methods of a vector (and sequential containers, in general) have only 
three types of operation: \textit{insertion}, \textit{deletion}, and \textit{search}. 
Methods such as $push\_back\left(\right)$, $pop\_back\left(\right)$, $front\left(\right)$, 
$back\left(\right)$, $push\_front\left(\right)$, and $pop\_front\left(\right)$ are only 
a simplified variation of those main methods, which are optimized for some containers 
(e.g., popping the last element of a stack).
%
To represent the model, consider a container $C\{cont\}$ with a method 
$cont.insert \rightarrow It$ that returns an iterator result and 
makes use of an iterator $It\{ipos\}$ that points to the desired 
insertion position; a template value $T\{val\}$ with the element 
to be inserted and an integer $N\{qtd\}$ that informs the amount 
of elements to be inserted in the desired position.

\[\begin{array}{ll}
%\label{eqnarray:transformations}
cont.insert(ipos, val, qtd) \Longrightarrow & cont'.size = cont.size \\
  & \wedge \: *ipos = val \\
  & \ldots \\
  & \wedge \: *(ipos + qtd - 1) = val \\
\end{array}\]

There is also another way to represent the insert method. 
It is possible to insert a sequence of elements in the desired 
insertion position, using both iterator or pointer bounds. 
Let $It\{it_0\}$ be an iterator that marks the first element 
to be inserted, $It\{it_k\}$ be another iterator that 
points to the first element after the end of the sequence to be inserted 
in the required position and let $N\{k\}$ be the length of the array $[it_0\, it_k)$. 

Therefore, we have:\\

\[\begin{array}{ll}
%\label{eqnarray:transformations}
cont.insert(ipos, it_0, it_k) \Longrightarrow & cont'.size = cont.size + k\\
  & \wedge \: *ipos = *it_0 \\
  & \ldots \\
  & \wedge \: *(ipos + k - 1) = *(it_k - 1)
\end{array}\]

The same model above is valid for pointers $P\{pt_0\}$ and $P\{pt_k\}$. 
This kind of insertion (with pointers) does not return a iterator.

The erase method works similarly to the insert method. It also uses iterator 
positions, integer values and pointers, but it does not use values, as the exclusion 
is made by a given position, regardless the value. It also returns a iterator position, 
pointing to the position next to the previously erased part of the container. 
The next model shows an erase method that deletes a single element:
%
\[\begin{array}{ll}
\label{erase1-model}
cont.erase (ipos) \Longrightarrow & cont'.size = cont.size - 1\\
  & \wedge \: ipos' = ipos + 1 \\
\end{array}\]

It is also possible to delete a number of elements from the container, 
marking the bounds with iterators. It works similarly to the equivalent 
insert method:

\[\begin{array}{ll}
\label{erase2-model}
cont.erase (ipos, it_0, it_k) \Longrightarrow & 	cont'.size = cont.size - k\\
  & \wedge \:	ipos' = it_k \\
\end{array}\]

Searches are made in a container by using reference operators 
and a pointing type (pointer or iterator), and return the reference 
value (the element stored itself). It can be considered as values 
$N\{*It\}$, $N\{*P\}$ or $N\{C_n\}$.	The structure of iterators 
is treated differently from other types. The model is the following:
$It = \{ ptr, n, addr\}$,
where $ptr$ is a memory address that points to the 
real position of the required element in the container 
(pointed by the iterator), $n$ is the iterator indexed 
internally in the container, and $addr$ is a memory 
address equivalent to $cont.array$, being $cont$ the container 
pointed by the iterator.

%---------------------------------
\subsection{General Libraries}
%---------------------------------

The libraries that performing more specific functions in the context of the C++ Standard
Libraries have been defined as General Libraries and are subdivide in four particular categories:
Language Support, Diagnostics, Strings and General Utilities.
The Language Support category is compose by four libraries that work respectively with
exception handling (exception), types information (typeinfo), dynamic allocation of memory (new) and 
numeric limits (limits). Each library contains an structure formed by classes, specific types, methods
and functions, however the limits library is one exception, seeing that it implements the definitions
related to numeric elements, therefore, your structure is formed by one class with the numeric
elements definitions and eight functions for manipulate this elements. A lot of functionalities related to
exception handling, dynamic allocation of memory and types information have been implement in the
ESBMC's kernel, however is important to have one representation about the libraries relationship to
this functionalities so that tool is capable of identify all methods and definitions related to same.

The stdexcept library is the only one the form the Diagnostic category, seeing that it
implements kind of standard exceptions divide in two subcategories: logic errors and runtime errors. To build it model, we defined the exception set 
$E$ assuming that $\left\{logic, domain, invalid\_argument, length, out\_of\_range, runtime, range, overflow, underflow\right\} \subset E$, 
being that represent an element within to set $E$ such that for each $e_{i}$exist
one class $\varphi(e_{i})$ that represent it, being that all $\varphi(e_{i})$ conatins one construtor that define a message contains a
constructor that sets a message to be thrown if there is of these errors in the program. Whenever one
of the constructors of these classes is called, one $assert(0)$ is throwing, forcing the ESBMC to identify this
error and report it in the counterexample. A hierarchical representation of the model can be observed
in Figure 5 and the formalization of the same in Figure 6.

The General Libraries category also includes definitions about the manipulation of characters sequences, such definitions are implemented in 
the library string. In the model constructed to represent this library, we implemented it structure through the class called string that contains 
the main features of the library, and the iterator class containing the representation of the iterator for strings. In general, we define the 
string object as an array of char, so that all heuristics that must be observed in handling vectors are therefore approached in this model. 
From of the principle that main operations implemented by this library are restricted to creation, insertion, deletion and search of elements 
inside to object string, we take as example the creation and search operations to exemplify and formalize the model created for this library. 
Therefore, firstly we assume $S$ as the set of string variables, $c$ as character non-deterministic, the set $\left\{n, i, pos, length\right\} \subset N$, 
and we define that s representing a string, the same has two attributes: the string size described by $length$, and a character sequence that 
represent it described by $str_{i}$, such that $i$ represent the position of some character inside to string. Keep this in mind, can be defined a 
constructor method that creates a string containing $n$ times the character $c$ and, furthermore the find method that search a character within a 
certain string from a given position described by $pos$. Such formalizations can be observed in the following.

\begin{equation}
\label{cconstructor-string}
C := \left [ \begin{array}{ll} 
                \bigvee^{n}_{j=0} str_{j} = store\left(str_{j}, i_{j}, c_{0}\right) 
              \end{array} \right ]  \\ 
\end{equation}
%
\begin{equation}
\label{pconstructor-string}
P := \left [ \begin{array}{ll} 
                \left(i_{0} \geq 0\right)  \, \, \wedge \, \, \left(i_{0} < \left(n_{0} + 1\right)\right)\\
                \ldots \\
                \wedge \, \, \left(i_{n} \geq 0\right)  \, \, \wedge \, \, \left(i_{n} < \left(n_{0} + 1\right)\right)\\
                \wedge \, \, c_{0} \neq 0\\
                \wedge \, \, n_{0} > 0\\
              \end{array} \right ]  \\ 
\end{equation}
%
\begin{equation}
\label{cfind-string}
C := \left [ \begin{array}{ll} 
                \left(c_{0} \neq \phi\right)\\
                \wedge \, \, \left(0 \leq pos \leq length\right)\\
                \wedge \, \, \left(0 \leq i_{n} \leq length\right)\\
              \end{array} \right ]  \\ 
\end{equation}
%
\begin{equation}
\label{pfind-string}
P := \left [ \begin{array}{ll} 
                \bigwedge^{length}_{j=0} str_{j+1} = ite\left(select\left(str_{j}, i_{j}\right) = c_{0}, i_{j}, -1\right)
              \end{array} \right ]  \\ 
\end{equation}

\subsection{Inheritance and Polymorphism}

Modeling C++ features like inheritance makes static analysis difficult to implement. We highlight the difficult in relation to other 
object-oriented languages, such as Java, the hierarchy of classes. C++ allows multiple inheritance, when a class may inherit from 
one or more classes, disallowing the direct use of tools already created for other languages like Java.
When a class inherits from a base class features not virtual, this is called replicated inheritance. If a class inherits from a base 
class virtual, has the name of shared inheritance.
A formal description to represent the relationship between the classes can be described by the Class Hierarchy Graph (CHG). 
This graph G is formed of a tuple $<$ \textbf{C},  $\prec s$, $\prec r >$,\textbf{C} being the set of classes. $ 
\prec_s \subseteq \textbf{C} \times \textbf{C}$, referring to shared inheritance edges and $\prec_r \subseteq 
\textbf{C} \times \textbf{C}$, are replicated inheritance edge. E $\prec_{sr} = \prec_s \bigcup \prec_r$.


We made an intermediate representation, see Figure~\ref{figure:multiple-inheritance-IR}.

\begin{figure*}[ht]
\centering
%\includegraphics[scale=0.7]{figures/multiple-inheritance}
\caption{Multiple inheritance: (a) C++ program, (b) class-inheritance graph.}
\label{figure:multiple-inheritance}
\end{figure*}

\begin{figure*}[ht]
\centering
%\includegraphics[scale=0.7]{figures/multiple-inheritance-IR}
\caption{Multiple inheritance intermediate representation.}
\label{figure:multiple-inheritance-IR}
\end{figure*}

This model transforms all the classes in structures and joins all methods and attributes of its parent classes.  This approach has the advantage in verification due the direct access, allowing an easier validation. On the other hand, we replicate information to any new class, wasting memory resources.
The indirect inheritance:

\begin{figure*}[ht]
\centering
%\includegraphics[scale=0.7]{figures/indirect-inheritance}
\caption{Indirect inheritance: (a) C++ program, (b) class-inheritance graph.}
\label{figure:indirect-inheritance}
\end{figure*}

\begin{figure*}[ht]
\centering
%\includegraphics[scale=0.7]{figures/indirect-inheritance-IR}
\caption{Indirect inheritance intermediate representation.}
\label{figure:indirect-inheritance-IR}
\end{figure*}

\subsection{Exception Handling}

One of the features that C++ provides over C is exception handling. The exceptions are unexpected situations on the program, situations 
that the program was not designed to handle. On C++, the exception handling is divided in two blocks: a try block and a catch block. 

The try block contains the code that is expected to run without errors and on the catch block, the code to handle errors from the try 
block. The connection between the two blocks is made by a throw expression. The throw statement is an expression of type void that 
invokes the handler from inside the try block and accepts one parameter, which is passed as parameter to the handler.

The exception handling brings a lot of advantages to the C++ development, because it allows the separation between code and error 
handling code. Futhermore, the exceptions propagates up in the stack, meaning that if a C++ program calls several functions, only 
one of than needs to handle the exceptions thrown.

\begin{figure}[ht]
\centering
\begin{minipage}{0.7\textwidth}
\begin{lstlisting}
int main() {
  // try block
  try {
    throw 20;
  }
  // catch block
  catch (int) { /* error handling */ }
  return 0;
}
\end{lstlisting}
\end{minipage}
\caption{Try-catch example: Throwing an int type.}
\label{figure:try-catch-example}
\end{figure}

\subsubsection{Throwing an Catching an Exception.}

There are also other ways to an exception be thrown by an program, other than the throw statement, such as the new operator can throw 
bad\_alloc exception, dynamic\_cast can throw bad\_cast exception and typeid can throw bad\_typeid exception. Also those exception are 
builtin on C++ and are supposed to be handled by the programmer during the development.

When throwing an exception the control and all the information are transferred to the handler. The rules to connect the exception with it´s
handler are defined on the C++ standard draft~\cite{CppDraft} as follow:

\begin{itemize}
 \item The handler that will catch the exception will be the first catch with a matching type.
 \item A handler will catch a exception thrown if the type of the throw and the type of the handler are the same (ignoring const-volatile
       qualifiers.
 \item Throwing "arrays of type T" and "functions returning type T" with be handled by handles with "pointer to type T" 
       and "pointer to function returning type T" types.
 \item The handler will catch an exception of type T if the handler type is an unambiguous public base class of T.
 \item The handler will catch an exception of type pointer T if T´s type can be converted to the type of the handler, either by 
       qualification conversion or standard pointer conversion.
 \item If the exception throw is a pointer then a handler with type void* or nullptr\_t can also catch it.
 \item A handler of type ellipsis (...) will catch any thrown exception, and shall be the last handler on the catch block.
\end{itemize}

\subsubsection{Rethrows and Exception Specifications.}

C++ also provides features as rethrows and exception specifications. The rethrows allows us to rethrow the last thrown exception, 
as shown on Figure~\ref{figure:try-catch-example-rethrowing-an-int-type}. Rethrows are useful for propagating the exception up in stacks with lots of try-catch blocks.

\begin{figure}[ht]
\centering
\begin{minipage}{0.7\textwidth}
\begin{lstlisting}
int main() {
  try {
    throw 20;
  }
  catch(...)  { 
    throw; // Rethrows type int
  }
  return 0;
}
\end{lstlisting}
\end{minipage}
\caption{Try-catch example: Rethrowing an int type.}
\label{figure:try-catch-example-rethrowing-an-int-type}
\end{figure}

Exception specifications define which exceptions a function or method can throw. Figure~\ref{figure:try-catch-example-allowing-that-only-int-type-can-be-thrown} shows an example of exception specifications
usage. They are useful when we want to forbid that certain types of exceptions can be thrown, for example, we can define that an function
or method cannot throw any exception.

\begin{figure}[ht]
\centering
\begin{minipage}{0.7\textwidth}
\begin{lstlisting}
// This function can only throw int types
void x() throw (int) { 
  throw 20;
}
int main() {
  try {
    x()
  }
  catch(...)  { 
    throw; // Rethrows type int
  }
  return 0;
}
\end{lstlisting}
\end{minipage}
\caption{Try-catch example: Allowing that only int type can be thrown.}
\label{figure:try-catch-example-allowing-that-only-int-type-can-be-thrown}
\end{figure}

\section{Experimental Results}
%
Experimental Results here (Mauro)...



\section{Related Work}

Prabhu et al. presents an interprocedural exception analysis and transformation framework for C++ that records the control-flow created by the exceptions 
and create a exception-free program. The exception-free program creation starts by generating a modular interprocedural exception control-flow graph (IECFG).
The IECFG is refined using a algorithm based on a compact representation for a set of types called the Signed-TypeSet domain and the result is used 
to generate the exception-free program. Finally, the exception-free program is verified using F-SOFT~\cite{Fsoft}. The verification focused on two properties:
"no throw", the percentage of the code that does not raise an exception and "no leak", the number memory leaks on try-catch blocks.~\cite{PrabhuMBIG11}

\section{Conclusions}
%
Conclusions here (Lucas)...


\smallskip{\small\noindent{\bf Acknowledgments.} 
%
Acknowledgments here (Lucas)...
}

\vspace{-2.5ex}
\renewcommand\refname{{\normalsize References}}
{\begin{thebibliography}{10}
\vspace{-0.5ex}

\bibitem{Sites74}
R.~L. Sites, ``Some thoughts on proving clean termination of programs.''
  Stanford, CA, USA, Tech. Rep., 1974.
  
\bibitem{PrabhuMBIG11}
P.~Prabhu, N.~Maeda, G.~Balakrishnan, F.~Ivancic, and A.~Gupta,
\newblock Interprocedural Exception Analysis for C++.
\newblock In {\em ECOOP}, pp. 583--608. 2011.

\bibitem{Blanc07}
N.~Blanc, A.~Groce, and D.~Kroening,
\newblock Verifying C++ with STL containers via predicate abstraction.
\newblock In {\em ASE}, pp. 521--524. 2007.

\bibitem{handbook09}
A.~Biere.
\newblock Bounded model checking.
\newblock In {\em Handbook of Satisfiability}, pp. 457--481. 2009.

\bibitem{Cimatti10}
A.~Cimatti, A.~Micheli, I.~Narasamdya, and M.~Roveri.
\newblock Verifying {SystemC}: a software model checking approach.
\newblock {\em FMCAD}, 2010, pp.\ 121--128.

\bibitem{Clarke04}
E.~Clarke, D.~Kroening, and F.~Lerda.
\newblock A tool for checking {ANSI-C} programs.
\newblock {\em TACAS}, {\em LNCS} 2988, pp.\ 168--176, 2004.

\bibitem{CordeiroPhD}
L.~Cordeiro.
\newblock {SMT}-Based Bounded Model Checking of Multi-Threaded Software in 
Embedded Systems.
\newblock PhD Thesis, U Southampton, 2011.

\bibitem{icse11}
L.~Cordeiro and B.~Fischer.
\newblock Verifying Multi-Threaded Software using {SMT}-based Context-Bounded 
Model Checking.
\newblock {\em ICSE}, pp.\ 331--340, 2011. 

\bibitem{sefm11}
J.~Morse, L.~Cordeiro, D.~Nicole, and B.~Fischer.
\newblock Context-Bounded Model Checking of LTL Properties for ANSI-C Software.
\newblock {\em SEFM}, {\em LNCS} 7041, pp.\ 302--317, 2011.

\bibitem{Armando09}
A.~Armando, J.~Mantovani, and L.~Platania.
\newblock Bounded model checking of software using {SMT} solvers instead of
  {SAT} solvers.
\newblock {\em STTT}, vol. 11 (1), pp. 69--83, 2009.

\bibitem{Ganai06}
M.~K. Ganai and A.~Gupta.
\newblock Accelerating high-level bounded model checking.
\newblock {\em ICCAD}, pp. 794--801, 2006.

\bibitem{Cordeiro12}
L.~Cordeiro, B.~Fischer, and J.~Marques-Silva.
\newblock {SMT}-based bounded model checking for embedded {ANSI-C} software.
\newblock {\em IEEE Trans. Software Eng.}, v.\ 38, n.\ 4, pp.\ 957--974, 2012. 

\bibitem{Florian12}
F.~Merz, S.~Falke, and C.~Sinz.
\newblock {LLBMC}: Bounded Model Checking of C and C++ Programs Using a Compiler IR.
\newblock {\em VSTTE}, pp.\ 146--161, 2012. 

\bibitem{OpenCpp12}
OpenC++, http://opencxx.sourceforge.net/, 2012.

\bibitem{CppDraft}
C.standards commitee. Working draft, standard for programming language C++ (2012),
\newblock {http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2012/n3376.pdf (acessed 8 october, 2012)}

\bibitem{CppReference12}
Reference of the C++ Language Library, http://www.cplusplus.com/reference/, 2012.

\bibitem{Fsoft}
F.~Ivancic, I.~Shlyakhter, A.~Gupta, M.~Ganai, V.~Kahlon, C.~Wang, Z.~Yang.
\newblock {Model Checking C programs using F-Soft.}
\newblock {\em IEEE International Conference on Computer Design.} pp.\ 297--308, October, 2005.

\end{thebibliography}}

\end{document}

