/*******************************************************************\
 *
 *
 * Author: Lucas Cordeiro
 *
 * 
\*******************************************************************/


#ifndef STL_LIST
#define STL_LIST

namespace std
{
	template<class T> class list
	{
	
	struct node
	{
		T data;
		node* prev;
		node* next;
		node(T t, node* p, node* n) : data(t), prev(p), next(n) {}
	};
	node* head;
	node* tail;
	int _size;

	
	public:
		list() : head( NULL ), tail ( NULL ), _size(0) {}

		list(T t) : head( NULL ), tail ( NULL ), _size(0) 
		{
			push_back(t);
		}

		list(T t1, T t2) : head( NULL ), tail ( NULL ), _size(0) 
		{
			push_back(t1);
			push_back(t2);
		}

		bool empty ( ) const 
		{
			return ( !head || !tail );
		}

		void push_back(const T& t)
		{
			tail = new node(t, tail, NULL);
			_size++;
			if( tail->prev )
				tail->prev->next = tail;
			if( empty() )
				head = tail;
		}

		void push_front ( const T& t )
		{
			head = new node(t, NULL, head);
			_size++;
			if( head->next )
				head->next->prev = head;
			if( empty() )
				tail = head;
		}

		void pop_back ( )
		{
			__ESBMC_assert ( !empty() , "list is empty");
			node* temp(tail);
			T data( tail->data );
			tail = tail->prev ;
			if( tail )
				tail->next = NULL;
			else
				head = NULL ;
			delete temp;
		}

		int size() const
		{
			return _size;
		}
	
		T back ( )
		{
			return tail->data;
		}

		const T back ( ) const
		{
			return tail->data;
		}

		const T front ( ) const
		{
			return head->data;
		}

		T front ( )
		{
			return head->data;
		}


		~double_linked()
		{
			while(head)
			{
				node* temp(head);
				head=head->next;
				delete temp;
			}
		}

	};
}

#endif
